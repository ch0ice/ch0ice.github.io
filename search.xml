<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机基础(1) --- 计算机硬件]]></title>
    <url>%2Fbasic%2Fbasic-1-hardware%2F</url>
    <content type="text"></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>计算机硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础(3) --- 网络协议]]></title>
    <url>%2Fbasic%2Fbasic-3-network%2F</url>
    <content type="text"><![CDATA[前言我们每天都在使用互联网，通过互联网聊天、购物、听音乐、看电影，全世界有几十亿台电脑通过互联网两两交互，那什么是互联网呢？互联网的核心是一系列协议，总称为互联网协议（Internet Protocol Suite），它们对电脑如何连接和组网，做出了详尽的规定，理解了这些协议，就理解了互联网的交互原理。 网络模型划分计算机网络的各层及其协议的集合被称为网络的体系结构，按照不同的维度，其常被分为七层、五层、四层网络结构，如下图所示： 七层网络模型 — OSI（Open System Interconnection）OSI — 开放式系统互联模型是一种概念模型，由国际标准化组织提出，并试图成为计算机在世界范围内互连为网络的标准框架，它具有七层网络结构。 四层网络模型 — TCP/IP互联网协议套件（Internet Protocol Suite，IPS）是多个网络传输协议的集合，它为网际网络的基础通信提供架构支撑，由于该协议族中最核心的两个协议分别为 TCP（传输控制协议）和 IP（网际协议），因此它也被称为 TCP/IP 协议族，简称TCP/IP，它具有四层网络结构。 五层网络模型 — TCP/IPOSI模型由国际标准化组织进行制定，它是正统意义上的国际标准，但其实现过于复杂、制定周期过长，在其整套标准推出之前，TCP/IP模型已经在全球范围内被广泛使用，所以 TCP/IP 模型才是事实上的国际标准。TCP/IP 模型定义了应用层、传输层、网际层、网络接口层这四层网络结构，但并没有给出网络接口层的具体内容，因此在学习和开发中，通常将网络接口层替换为OSI七层模型中的数据链路层和物理层来进行理解，由此产生TCP/IP五层网络模型。下面我们会对五层网络模型从下至上展开详细讲解。 物理层（Physical Layer）电脑之间组网第一件事是通过网卡、网线、集线器、中继器、调制解调器、光缆、电缆、双绞线、无线电波等物理设备将电脑之间连接起来。这就是物理层，是把电脑之间连接起来的物理手段，该层为上层协议提供了一个传输数据的可靠的物理媒体，它规定了网络的一些电气特性，比如高电压1、低电压0，组成比特流进行传输。 数据链路层（Data Link Layer）数据链路层在物理层提供的服务的基础上向网络层提供服务，物理层单纯的电信号0和1没有任何意义，必需规定解读方式，如电信号多少位一组、每组什么意思，它规定了电信号的分组方式，以及物理寻址（MAC），将源自网络层来的数据可靠地传输到相邻节点的目标主机的网络层（广播）。 以太网协议（Ethernet Protocol）早期的时候各个公司都有自己的分组方式、后来形成了统一的分组成帧标准，即以太网协议。以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame），每一帧分成两个部分：报头（Head）和数据（Data）。Head部分为定长18字节，Data部分为46 ~ 1500字节，因此单帧最小长度为64字节（head 18 + data 46）， 单帧最大长度为1518字节（head 18 + data 1500），如果超出最大长度就分割成多个帧进行发送。 MAC地址（Media Access Control Address）上面提到以太网数据包（Frame）的报头（Head）中包含源地址和目标地址信息就是网卡地址，即MAC地址。每块网卡出厂时都有一个全世界独一无二的MAC地址，长度为6字节48位，通常用12个十六进制数表示，前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。 广播（Broadcasting）我们现在知道了以太网数据包（Frame）的报头（Head）中包含的地址信息是MAC地址，我们知道本机网卡的MAC地址，但是我们还需要获取对端主机网卡的MAC地址，怎么获取呢？答案是通过一种叫ARP的协议（下面会讲），我们可以得到对端主机网卡的MAC地址，但是怎么才能把数据包准确送到接收方呢？答案是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有主机发送，让每台计算机自己判断自己是否为接收方，它们读取这个包的”标头”找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包做进一步处理，否则就丢弃这个包，这种发送方式就叫做”广播”（broadcasting）。 网络层（Network Layer）有了以太网数据包的定义、网卡的MAC地址、广播的发送方式，世界上的计算机就可以彼此通信了。问题是互联网是由一个个彼此隔离的子网组成的，广播出去的消息只有在同一子网内的主机才会收到，两个主机不在同一子网对端是收不到的，这种设计是合理的，如果一台主机发送的包全世界都会收到，这就不仅仅是效率低的问题了，这将会是一种灾难。因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用路由（向不同广播域/子网分发数据包）方式发送，遗憾的是，MAC地址本身无法做到这一点，它只与厂商有关，与所处网络无关。至此网络层诞生了，它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络，这套地址就叫做网络地址，简称网址。网络层出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址，两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡，因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。 IP协定规定网络地址的协议叫IP协议，它定义的地址称之为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4，IPv4规定网络地址由4字节点分十进制表示。例如：127.0.0.1，范围：0.0.0.0 ~ 255.255.255.255IP地址分成两部分，网络部分(标识子网)和主机部分(标识主机)，如果两个IP地址的网络部分相同，那就说明它们在同一子网内，但是我们不能确定IP地址中哪一部分是用来标识子网的，这就需要一个参数，子网掩码。 子网掩码子网掩码就是用来确定IP地址中网络特征的一个参数，它在形式上等同于IP地址，同样是4字节点分十进制表示，转为二进制以后它的网络部分全部为1、主机部分全部为0，然后与IP地址进行按位与（&amp;）运算，就可以得到IP地址中的网络部分。例如：IP地址为：172.20.10.4，子网掩码为：255.255.255.0，那么就代表IP地址中前24位为网络部分，后8位为主机部分，就可以得出IP地址中的网络部分为：172.20.10.0 IP数据包IP数据包也分为Head和Data部分，如下图所示：IP数据包最大长度为65535字节，为理论上的最大长度，但前面说过以太网数据包的Data部分最长只有1500字节，因此，如果IP数据包超过了1500字节，它就需要分割成多个以太网数据包，分开发送了。以太网协议无须为IP数据包定义单独的栏位，直接放入以太网包的Data部分即可，如下图所示： ARP（Address Resolution Protocol）/RARP（Reverse Address Resolution Protocol）因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址，对方的IP地址是已知的，但是我们不知道它的MAC地址，所以我们需要一种机制能够通过IP地址得到MAC地址，就是ARP — 地址解析协议。ARP — 地址解析协议，也是一个数据包，如下所示：ARP数据包同样包含在以太网数据包中，这个包会以广播的方式在发送端所处的子网内传输，在发送时目标主机MAC地址为FF:FF:FF:FF:FF:FF，表示这是一个广播地址，目标主机接收到ARP数据包后从中取出IP地址，与自身的IP地址进行比较，发现目标IP为本身的，就返回本身的MAC地址，否则就丢弃这个包。需要注意的是，如果目标主机不在同一子网，那么ARP数据包中的目标主机IP为本机所在子网的网关IP。RARP — 逆地址解析协议，功能和ARP协议相对，其将局域网中某个主机的MAC地址转换为IP地址。 传输层（Transport Layer）网络层的IP帮我们区分子网，数据链路层的MAC帮我们找到主机，然后大家使用的都是应用程序，你的电脑上可能同事运行多个应用程序如播放器、聊天软件等，那么我们通过IP和MAC找到了一台特定的主机，如何标识这台主机上的应用程序呢？答案便是端口（Port），端口即应用程序与网卡关联的编号，每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。端口是一个两字节的整数，范围是0到65535之间，0到1023的端口被系统占用，用户只能选用大于1023的端口，不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。传输层的功能就是建立端口到端口的通信，相比之下网络层的功能是建立主机到主机的通信，只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做Socket（下面会讲），有了它，就可以进行网络应用程序开发了。 UDP（User Datagram Protocol）有了端口以后，我们必须在数据包中加入端口信息，这就需要新的协议，最简单的实现叫做UDP — 用户数据报协议，它的格式几乎就是在数据前面，加上端口号。UDP数据包，也是由Head和Data两部分组成，UDP数据包总长度最大65535字节，Head部分为定长8字节，Data部分为变长65527字节，如下图所示：UDP数据包需要放在IP数据包的Data部分，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样： TCP（Transmission Control Protocol）UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了，这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认，如果有一个数据包遗失，收不到确认，发出方就会认为这个包发送失败重新发送这个数据包。因此，TCP协议能够确保数据不会遗失，它的缺点是过程复杂、实现困难、消耗较多的资源。TCP数据包，也是由Head和Data两部分组成，Head部分为定长20字节加变长4字节扩展，TCP数据包和UDP数据包一样，都是内嵌在IP数据包的Data部分，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 TCP — 三次握手四次挥手由于我们大部分使用的应用层协议都基于TCP协议通信，所以这里重点讲一下TCP协议。上面说过了，TCP是基于连接的可靠性传输协议，TCP提供面向有连接的通信传输，面向有连接是指在数据通信开始之前先做好两端之间的准备工作，由此保证连接的可靠性。如上图所示，TCP交互有三个阶段，连接创建、数据传输、连接销毁。连接创建（三次握手）：创建连接需要三次握手，是指建立一个TCP连接时需要客户端和服务器端总共发送三个包以确认连接的建立（Socket编程中，由客户端执行connect函数来触发)。 第一次握手：Client发送SYN包，请求建立新连接，Server收到Client发送的SYN包，此时Server知道：Client发送能力正常，自己的接收能力正常。 第二次握手：Server发送ACK包，表示收到Client发送的SYN包并同意创建新连接，Client收到Server发送的ACK包，此时Client知道：自己的收发能力都没问题，Server收发能力也没问题，但此时Server端还不知道自己的发送能力是否有问题，所以需要第三次握手。 第三次握手：Client发送ACK包，Server收到Client发送的ACK包，此时Server知道：Client和自己的发送和接收能力都没问题，到此连接创建阶段完成。数据传输：连接建立完成后，双方开始收发业务数据。连接销毁（四次挥手）： 第一次挥手：Client发送FIN包，请求断开连接，Server收到Client发送的FIN包，此时Server知道：Client已经没有新数据发送给自己了。 第二次挥手：Server发送ACK包，告诉Client自己已经收到了断开连接请求，Client收到Server发送的ACK包，此时Client知道：Server端收到了自己的断开连接请求，但是还不知道Server端有没有数据给自己。 第三次挥手：Server发送FIN包，告诉Client自己也没有数据需要传输了，Client收到Server发送的FIN包，此时Client知道：Server也没有数据需要发送给自己了，但是Server不知道自己是否收到了这个通知，所以需要第四次挥手。 第四次挥手：Client发送ACK包，告诉Server自己已经收到了通知，至此，双方都可以确认对端不会再有数据发送给自己，断开连接。TCP — 为什么握手需要三次，而挥手需要四次TCP连接在传输数据前需要双方需要确定对端的收发能力是否正常，以此为前提则必须要握手三次，可以查看上面三次握手流程。那么为什么断开连接需要四次挥手呢，因为创建连接与断开连接有个本质区别就是断开连接前是可能有数据在传输的，正常情况断开连接的流程是由Client触发的，Server突然收到断开连接的请求，然后返回ACK包告诉Client自己已经收到请求，但是Server需要检查是否有数据在传输，由于TCP连接是全双工的，所以双方需要确定都不会进行数据传输后才可以关闭，Server检查并处理完正在传输的数据以后会主动给Client发送FIN包，告诉Client自己也没数据需要传输了，已经准备好断开连接了，这一步就是多出来的那一次挥手。 应用层（Application Layer）应用程序收到传输层的数据，接下来就要进行解读，由于互联网是开放架构，大家都可以开发本身的应用程序，数据来源五花八门，必须事先规定好格式，否则根本无法解读。因此产生了应用层，作用就是规定应用程序的数据格式，这是最高的一层，直接面对用户，它的数据就放在TCP/UDP数据包的Data部分，于是到了应用层以太网的数据包就变成下面这样： DHCP（Dynamic Host Configuration Protocol）DHCP — 动态主机配置协议，它的数据包结构如下：DHCP是建立在UDP协议上的应用层协议，整个数据包形式为：DHCP采用客户端（67端口）／服务器模式（68端口），客户端通过DHCP协议和DHCP服务交换信息，服务器会返回分配给客户端的网络地址信息（IP、子网掩码、网关地址、DNS服务器等等）。DHCP提供三种IP分配方式： 自动分配是当DHCP客户端第一次成功的从DHCP服务器获取一个IP地址后，就永久的使用这个IP地址。 手动分配是由DHCP服务器管理员专门指定的IP地址。 动态分配是当客户端第一次从DHCP服务器获取到IP地址后，并非永久使用该地址，每次使用完后，DHCP客户端就需要释放这个IP，供其他客户端使用。DNS（Domain Name System）DNS — 域名系统，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串，简单来说DNS就是维护域名与IP地址之间关系的系统。DNS协议使用了UDP和TCP两种协议，并占用对应协议的53端口，DNS数据包结构如下：增加了DNS数据包的以太网协议结构如下：Socket我们知道两个进程如果需要进行通讯最基本的一个前提是能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道网络层IP协议中的IP地址可以标识唯一主机，而传输层TCP/UDP协议的端口号可以唯一标示主机的一个进程，这样我们可以利用IP地址＋协议＋端口号精准标识出网络中的一个进程。能够唯一标示网络中的进程后，它们就可以利用Socket进行通信了，什么是socket呢？我们常常把Socket翻译为套接字，Socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用用来实现应用程序进程的网络通信。Socket起源于UNIX，在UNIX一切皆文件哲学的思想下，Socket是一种打开—读/写—关闭模式的实现，服务器和客户端各自维护一个文件（SocketFD），在建立连接打开后，可以向本身文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。 网络通信流程以访问www.google.com为例，来模拟一个完整的网络通信，用来梳理一下上面所讲到的知识。一台计算机要访问网络资源首先要连接网络，连接网络需要四个必要参数，IP地址、子网掩码、网关IP、DNS，获取IP地址分有两种方式，一是手动填写网络管理员分配的IP地址，二是通过DHCP服务动态获取IP地址，我们以第二种为例。 通过DHCP服务获取IP地址、子网掩码、网关IP、DNS等网络信息，让计算机连接网络 然后浏览器输入网址www.google.com，经过DNS服务解析成目标主机的IP地址 由于访问www网址使用的是应用层的HTTP协议，浏览器生成HTTP请求数据包，假设生成HTTP请求包大小为2000字节。 HTTP数据包需要放置在传输层TCP协议的Data部分，TCP数据包Head部分需要设置通信双方的端口，HTTP协议默认端口80，所以目标端口为80，源端口为本机随机生成（1023 ~ 65535），由于TCP协议的Head部分为定长20字节，所以目前的数据包大小为2020字节。 然后TCP数据包需要放置在IP数据包的Data部分，IP数据包Head部分需要设置通信双方的IP地址，本机IP地址通过DHCP已经得知，目标主机IP地址通过DNS服务也知道了，由于IP协议的Head部分为定长20字节，所以目前的数据大小为2040字节。 最后IP数据包放置在数据链路层以太网帧的Data部分，以太网数据包Head部分需要设置通信双方的MAC地址，源MAC地址为本机网卡的MAC地址，目标MAC地址通过ARP协议得到，由于DNS服务返回www.google.com域名所对应的IP地址与本机IP不在同一子网，所以在发送ARP请求时ARP协议中的目标IP地址为本机所在子网的网关IP（DHCP返回），目标MAC地址则为FF:FF:FF:FF:FF:FF，表明这是一个广播地址。 由于以太网协议规定Data部分最大为1500字节，但是目前数据有2040字节，所以会分成两包发送。 经过多个网关的转发，google服务器收到来自我们本机的发送的两个以太网数帧，根据IP数据包Head部分的序号将两包数据拼接起来，取出完整的TCP数据，然后读取TCP数据包里面的的HTTP请求数据，接着做出HTTP响应，在用TCP协议发送回来，响应步骤和我们发送步骤一样，本机接收到来自google服务器的响应数据以后，将网页显示出来，到此，一次网络通讯就结束了。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>网络协议</tag>
        <tag>互联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机基础(2) --- 操作系统]]></title>
    <url>%2Fbasic%2Fbasic-2-os%2F</url>
    <content type="text"></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty指南（6）--- HTTP协议开发]]></title>
    <url>%2Fnetty%2Fnetty-guide-6-http%2F</url>
    <content type="text"><![CDATA[前言本章内容包括HTTP协议介绍、HTTP协议在Netty中的应用，并提供基于HTTP协议栈的Netty示例代码。 HTTP介绍HTTP — Hyper Text Transfer Protocol 超文本传输协议，是建立在TCP/IP传输协议上的应用层协议，它属于应用层的面向对象协议，由于其简洁、快速的方式，适用于分布式超媒体信息系统。HTTP协议时目前Web开发的主流协议，基于HTTP的应用非常广泛，因此掌握HTTP的开发非常重要。本文主要介绍基于Netty的HTTP协议栈开发，由于Netty的HTTP协议栈是基于NIO通信框架开发的，因此Netty的HTTP协议也是非阻塞的。 HTTP 协议的特点 简单 — 客户向服务端请求服务时，只需要制定服务的URL，携带必要的请求参数或请求消息体。 灵活 — HTTP允许传输任意类型的数据对象，传输的内容类型由HTTP消息头中的ContentType标记。 无状态 — HTTP是无状态协议，无状态指协议对事务处理没有记忆功能，意味着后续请求处理需要之前的信息只能重传，这样可能导致每次传输数据量增大，但对于服务器不需要处理之前的信息时，就显得轻量。 HTTP URL（Uniform Resource Locator） WWW：World Wide Web — 万维网 URL：Uniform Resource Locator — 统一资源定位符 URI：Uniform Resource Identifier — 统一资源标识符URL是一种特殊类型的的URI，是WWW上每个信息资源统一且唯一的地址，它最初是由 Tim Berners-Lee 发明用来作为WWW的地址，现在它已经被万维网联盟编制为互联网标准RFC1738。HTTP URL的地址如下： http :// host[:port] / abs_path http：表示要通过HTTP协议来定位网络资源。 host：表示合法的Internet主机域名或IP地址，以目前主流的IPV4协议为例，IPV4使用4字节点分十进制表示，例如：127.0.0.1 port：用于指定一个端口号，拥有被请求资源的服务器主机监听该端口的TCP连接，如果port是空，则使用缺省端口80，当服务器的端口不是80的时候，需要显式指定端口号。 abs_path：指定请求资源的URI，如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器就帮我们完成了。 HTTP RequestHTTP的请求消息由三部分组成，具体如下图所示。 HTTP ResponseHTTP的响应消息由三部分组成，具体如下图所示。]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>并发编程</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty指南（5）--- 编解码技术]]></title>
    <url>%2Fnetty%2Fnetty-guide-5-codec%2F</url>
    <content type="text"><![CDATA[前言Netty提供了强大的编解码器框架，使得我们编写自定义的编解码器很容易，也容易封装重用。在网络应用中需要实现某种编解码器，将原始字节数据与自定义的消息对象进行互相转换。网络中都是以字节码的数据形式来传输数据的，服务器编码数据后发送到客户端，客户端需要对数据进行解码。编码：将消息对象转成字节或其他序列形式在网络上传输解码：负责将消息从字节或其他序列形式转成指定的消息对象 TCP粘包/拆包解码器上层的应用协议为了对消息进行区分，往往采用如下4种方式，也就是我们上一节中讲到的TCP粘包/拆包问题的4种解决方案： 将消息长度固定，例如将消息长度len = 100，累计读到100字节后就认为读到了一个完整的消息。 将回车换行符（System.getProperty(“line.separator”)）作为消息结束符，例如FTP协议，这种方式在问本协议中应用比较广泛。 将特殊的分割符作为消息的结束标志，回车换行符就是一种特殊的结束分隔符。 将消息分为消息头和消息体，消息头中包含消息总长度或消息体长度的字段。 Netty对这4种方式做了统一抽象，提供了4种解码器来解决对应的问题，下面我们分别介绍一下这4种解码器。由于下面介绍的4种解码器都是为了解决TCP粘包/拆包，所以为了保证发生TCP粘包/拆包现象，每个示例代码中client端都会连续发送多条消息到server。 FixedLengthFrameDecoderFixedLengthFrameDecoder可以处理长度固定的消息，它有1个参数，int frameLength，当累计读到frameLength个Byte的时候就认为读到了一个完整的消息。 Type Name Describe int frameLength 帧长度，当累计读到frameLength个Byte的时候就认为读到了一个完整的消息 点击查看FixedLengthFrameDecoder解码器完整示例代码 示例代码中client向server发送100条消息，由于我们演示的是定长消息解码器，但client与server消息长度不一致，所以server端并没有发送响应消息给client，所以查看server端接收消息的日志即可，你会发现并没有出现TCP粘包/拆包现象。 LineBasedFrameDecoderLineBasedFrameDecoder可以处理以回车换行符结尾的消息，它有如下3个参数： Type Name Describe int maxLength 整帧数据的最大长度，整帧数据长度超过maxLength会抛出TooLongFrameException异常。 boolean stripDelimiter stripDelimiter = true：解码后的消息中去掉分隔符stripDelimiter = false：解码后的消息中包含分隔符默认：stripDelimiter = true boolean failFast failFast = true：消息长度超过 maxLength 是否立即抛出异常failFast = false：读取到换行符以后才抛出异常默认：failFast = false。 点击查看LineBasedFrameDecoder解码器完整示例代码 示例代码中我们同样是让client向server发送100条消息，并在消息结尾增加换行符（System.getProperty(“line.separator”)），运行代码你会发现client与server消息都被正常处理了。 DelimiterBasedFrameDecoderDelimiterBasedFrameDecoder可以处理以自定义分隔符结尾的消息，你可以定义任何符号，只要是你数据中用不到的符号都可以，它有4个参数和1个特殊的可变长参数： Type Name Describe int maxLength 整帧数据的最大长度，整帧数据长度超过maxLength会抛出TooLongFrameException异常。 boolean stripDelimiter failFast = true：解码后的消息中去掉分隔符failFast = false：解码后的消息中包含分隔符默认：failFast = true boolean failFast failFast = true：整帧数据长度超过 maxLength 是否立即抛出异常failFast = false：读取到换行符以后才抛出异常默认：failFast = false ByteBuf delimiter 消息的分隔符，将你定义的分隔符转为ByteBuf传入例如 Unpooled.copiedBuffer(&quot;^_^&quot;.getBytes()) ByteBuf… delimiters 与delimiter的区别是，这是个可变长参数，它允许你以ByteBuf[]数组形式传入多个分隔符例如new ByteBuf[]{Unpooled.copiedBuffer(&quot;^_^&quot;.getBytes()),Unpooled.copiedBuffer(&quot;#_#&quot;.getBytes())} 点击查看DelimiterBasedFrameDecoder解码器完整示例代码 LengthFieldBasedFrameDecoderLengthFieldBasedFrameDecoder可以处理自定义length字段的可变长消息，它需要你的业务协议中包含length字段，根据读取到的length字段来计算整帧数据的长度，它有如下7个参数： Type Name Describe ByteOrder byteOrder 字节序大端序：byteOrder = ByteOrder.BIG_ENDIAN小端序：byteOrder = ByteOrder.LITTLE_ENDIANJava采用大端字节序保存数据，如果你的业务协议本身就是大端字节序，则就无需设置。 int maxFrameLength 完整数据包的最大长度，整帧长度超过maxFrameLength会抛出TooLongFrameException异常。 int lengthFieldOffset 整帧数据中length字段的起始索引 int lengthFieldLength 整帧数据中length字段所占字节长度 int lengthAdjustment length字段的补偿值，这个值的设置取决于你业务协议中length字段的值，如果length字段为整包长度，那么lengthAdjustment的值一般为负值，如果length字段为数据体长度，数据体后面还有数据的话，就要通过lengthAdjustment告诉解码器后面还有多少个字节的数据。 int initialBytesToStrip 从解码帧中取出的第一个字节数，可以理解为需要调过的字节数，比如完整数据包长度10字节，length字段占用4字节，剩下6字节为数据体，如果你想只保留数据体，你可将lengthAdjustment=4，length字段所占用的4字节就会被丢弃。 boolean failFast failFast = true：整帧数据长度超过 maxLength 是否立即抛出异常failFast = false：读取到换行符以后才抛出异常默认：failFast = false 点击查看LengthFieldBasedFrameDecoder解码器完整示例代码 自定义编解码器Netty为我们抽象了编解码操作，在Netty程序中我们只需要继承下面对应的抽象类，重写其对应的编解码方法，并把编解码器追加到ChannelPipeline中，Netty就会执行我们自定义的编解码器。 MessageToByteEncoder 通过重写encode方法，将用户定义的类型转化为byte类型 MessageToMessageEncoder 通过重写encode方法，将用户定义的类型转化为另外一种用户定义的类型 ByteToMessageDecoder 通过重写decode方法，将byte类型转化为用户定义的类型 MessageToMessageDecoder 通过重写decode方法，将用户定义的类型转化为另外一种用户定义的类型 下面链接的代码中，我们分别实现了2个编码器和2个解码器，为了让示例代码变得更加简单，我没有创建自定义的Java对象，而是直接使用字符串类型来代替我们自定义的对象。自定义编解码器示例代码及client与server的编解码器调用流程图如下： 点击查看Netty自定义编解码器完整示例代码 Java原生序列化存在的问题Java原生序列化起源于JDK1.1，他不需要添加额外的类库，只需要 implements java.io.Serializable 并生成 serialVersionUID 即可，应用广泛。但是在远程服务调用（RPC）时很少使用Java原生序列化进行消息的编解码和传输，这是为什么呢，下面来分析一下Java序列化的缺点。 无法跨语言这是Java原生序列化的致命问题，对于跨进程调用，对端很可能使用其他语言，如C++、Python等，当我们需要和异构语言的程序交互时，Java原生序列化就难以胜任了。由于Java序列化是Java语言内部的私有协议，其他语言并不支持，对于用户来说它完全是黑盒，使用Java原生序列化后的字节数组，其他语言是没有办法反序列化的，所以目前几乎所有流行的Java RPC通信框架都没有使用Java原生序列化作为编解码框架，主要原因就在于它无法跨语言。 序列化后的码流太大 点击查看Java原生序列化码流大小测试完整示例代码 测试代码的运行结果表明，Java原生序列化的码流大小 是 二进制编码 6倍左右，受数据影响可能差距更大。评价一个编解码框架往往会考虑以下因素： 是否支持跨语言，支持的语言种类是否丰富 编码后的码流大小 编解码性能 类库是否轻量，API是否简单易用在同等情况下，编码后的码流越大，存储的时候占用的空间就越大，硬件成本就越高，在网络传输中占用带宽越高，进而导致系统吞吐量降低。所以Java原生序列化，除了无法跨语言，码流太大也是一个很大的缺点。 序列化性能低 点击查看Java原生序列化性能测试完整示例代码 测试代码的运行结果表明，在100w次的序列化测试中，Java原生序列化耗时 是 二进制序列化 7倍左右，受数据影响可能差距更大。但也足以表明Java原生序列化 无论是 码流大小 还是 性能，都表现的很差，因此我们通常不会选择Java序列化作为RPC调用的编解码框架。 主流第三方编解码框架下面介绍一些业界主流的编解码框架，并提供示例代码。 MessagePackMessagePack是一个高效的二进制序列化框架，与JSON类似，支持不同语言间的数据交换，但MessagePack的性能更高，编码后的码流更小。 MessagePack官网 点击查看MessagePack编解码完整示例代码 ProtobufProtobuf — Google Protocol Buffer，由Google开源的一款结构化数据序列化框架，相比于传统的MXL/JSON等，它更小，更快。它将数据结构以 .proto 文件进行描述，通过代码生成工具可以生成数据结构对应的对象和Protobuf相关的属性和方法。 Protobuf官网 点击查看Protobuf编解码完整示例代码 MarshallingMarshalling 是由 JBoss开源的一个Java序列化框架，它修正了JDK自带序列化包的很多问题，但又保持和 java.io.Serializable 接口的兼容，同时增加了可调参数和特性可通过工厂类进行配置。 Marshalling官网 点击查看Marshalling编解码完整示例代码 table th:first-of-type { width: 15%; } table th:nth-of-type(2) { width: 25%; } table th:nth-of-type(3) { width: 60%; }]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>并发编程</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty指南（4）--- TCP粘包/拆包]]></title>
    <url>%2Fnetty%2Fnetty-guide-4-unpacking%2F</url>
    <content type="text"><![CDATA[前言本节我们会介绍TCP的粘包和拆包，什么是TCP粘包/拆包，怎么解决粘包问题，以及代码演示。 TCP粘包/拆包介绍TCP是个”流”协议，没有界限，因为TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分。一个完整的数据包可能会被TCP拆分成多个包进行发送，也可能把多个小的包封装成一个大的数据包发送，这就是TCP粘包/拆包的由来。上图以两个完整数据包（D1、D2）为例，演示了可能发生的4种情况，分别如下： 服务器分两次读到了两个独立数据包，分别是D1和D2，没有发生粘包和拆包。 服务器一次接受到了两个数据包，D1和D2粘在了一起，被称为TCP粘包。 服务器分两次读到了两个数据包，第一次读到了完整的D1+部分D2，第二次读到了D2的剩余部分，被称为TCP拆包。 服务器分两次读到了两个数据包，第一次读到了D1的一部分，第二次读到了D1剩余部分+D2完整包，这种即发生了粘包现象也发生了拆包现象。 TCP粘包/拆包问题的原因导致发生TCP粘包/拆包现象的原因有三个，分别如下： 应用程序write写入的字节数量大于套接口发送缓冲区的大小。 进行MSS(maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。）大小的TCP分段。 以太网帧的payload大于MTU（maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节，其中包括 IPHeader（20Byte）TCPHeader（20Byte））进行IP分片。 TCP粘包/拆包的解决方案由于底层TCP无法理解上层业务数据，所以底层无法保证数据不被拆分和重组，这个问题只能通过上层的应用协议栈设计来解决，有如下几种解决方案： 将消息长度固定，例如将消息长度len = 100，累计读到100字节后就认为读到了一个完整的消息。 将回车换行符（System.getProperty(“line.separator”)）作为消息结束符，例如FTP协议，这种方式在问本协议中应用比较广泛。 将特殊的分割符作为消息的结束标志，回车换行符就是一种特殊的结束分隔符。 将消息分为消息头和消息体，消息头中包含消息总长度或消息体长度的字段。 未处理TCP粘包导致的功能异常案例我们之前提供的所有示例代码中都没有包含，TCP粘包/拆包的处理，在功能测试上一般不会出现问题，但是一旦客户端增多服务器的压力增加，或者发送较大数据包时就会出现粘包/拆包问题。如果程序没有处理粘包/拆包，往往会出现解码错误的错误，导致程序不能正常工作。我为了制造TCP粘包/拆包的问题，将客户端向服务器发送消息的代码块增加了循环，发送100次消息给服务器，并增加了计数。 点击查看Netty未处理TCP粘包导致的功能异常案例完整示例代码 启动上面代码的客户端和服务器查看结果，你会发现服务器只收到了一个消息，并回复了一个应答，由于客户端发送的消息发生粘包，不满足时间服务器查询条件，所以返回了 “QUERY FAIL”。 处理了TCP粘包的正常功能案例我们再看处理了TCP粘包/拆包的程序，由于我们的实例程序比较简单，只操作字符串，因此代码中我在客户端发给服务器的消息和服务器返回给客户端的消息后面增加了换行分隔符（System.getProperty(“line.separator”)）,并且使用了Netty内置的解码器 LineBasedFrameDecoder 来解决TCP粘包问题。为了解决TCP粘包/拆包导致的读写问题，Netty默认提供了多种编解码器用于处理粘包问题，你也可以自己实现编解码器，关于Netty编解码器我们下节会介绍，这里不展开详述。 点击查看Netty处理了TCP粘包的正常功能案例完整示例代码 启动上面代码的客户端和服务器查看结果，你会发现服务器收到了100条客户端的请求消息消息，客户端同样收到了100条服务器的响应消息消息，并给出了正确的响应内容，这说明我们已经正确的处理了TCP的粘包问题。]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>并发编程</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty指南（3）--- Netty入门]]></title>
    <url>%2Fnetty%2Fnetty-guide-3-basic%2F</url>
    <content type="text"><![CDATA[前言本文我们将会介绍什么是Netty，为什么要选择Netty，以及Netty的特性。 什么是NettyNetty是一个Java语言开发的高性能非阻塞I/O client/server框架，它支持快速、简单的开发client/server网络应用程序，大大简化了网络编程，如：TCP、UDP套接字服务器等。Netty的”快速而简单”并不意味着使用它开发出的应用程序会遭遇可维护性或性能问题，Netty经过非常精心的设计（也许这就是艺术），积累了多种协议（FTP、SMTP、HTTP、各种二进制协议和基于文本的遗留协议）实现的经验。 选择Netyy的理由为什么不使用原生NIO类库进行开发 NIO类库和API繁杂且使用麻烦，需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。 需要具备其他的额外技能做铺垫，例如熟悉Java多线程编程，这是因为NIO编程设计Reactor模式，必须对多线程和网络编程非常熟悉，才能编写出高质量的NIO程序。 可靠性能力补齐，工作量和难度都非常大，例如客户端重连、半包读写、失败缓存、异常码流的处理等问题，且还需要很好的模块设计才能保证代码更改起来不会牵一发动全身。 JDK NIO的BUG，例如epoll bug，它会导致Selector空轮询，最终导致CPU 100%，官方称JDK 1.6（6u4）版本修复了该问题，但直到JDK 1.7版本该问题依旧存在，只是发生概率降低了而已，如果你想了解该bug的细节，可以点击下面两个链接查看。 点击查看JDK NIO epoll bug详情 点击查看JDK NIO epoll bug详情 为什么选择Netty Netty是业界流行的NIO框架之一，它的健壮性、功能、性能、可定制和可扩展性是目前NIO框架中最好的，它已经得到成千上万的商用项目验证。 统一的API，使用简单，支持多种传输类型，阻塞或非阻塞的，内置了多种编解码功能，支持多种主流协议。 易于使用，完备的Javadoc和大量的示例集。 高性能，拥有比Java的核心API更高的吞吐量以及更低的延迟，得益于池话和服用，拥有更低的资源消耗，最少的内存复制。 健壮性强，不会因为慢速、快速或超载的连接而导致OutOfMemoryError，消除在高速网络中NIO应用程序常见的不公平读/写问题。 安全性，完整的SSL/TSL/StartTLS支持 定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展。 成熟、稳定，Netty修复了已经被发现的所有JDK NIO Bug，业务开发人员不需要为JDK NIO本身存在的问题而苦恼。 社区活跃，版本迭代周期短，发现Bug能被及时修复。 使用JDK NIO开发与使用Netty的对比下面是两种方式编写一个非常简单的NIO程序的流程，流程中不涉及TCP粘包拆包和编解码细节。 使用JDK NIO的开发流程 创建ServerSocketChannel，并配置它为非阻塞模式； 绑定监听，配置TCP参数，例如backlog、sndbuf等； 创建一个独立的I/O线程，用于轮询Selector； 创建Selector，将之间创建的ServerSocketChannel注册到Selector上，监听SelectionKey.ACCEPT； 启动I/O线程，再循环体重执行Selector.select()方法，轮询就绪的Channel； 当轮询到了就绪状态的Channel是，需要判断其状态，如果是ACCEPT状态，说明是新接入的客户端，则调用ServerSocketChannel.accept()接受客户端连接； 将SocketChannel注册到Selector上，监听OP_READ操作位； 如果Channel状态为OP_READ，则说明SocketChannel有新的就绪的数据包需要读取，则构造ByteBuffer读取数据包； 如果Channel状态为OP_WRITE，说明还有数据没有发送完成，需要继续发送。使用Netty NIO的开发流程 创建 NIO 线程组 EventLoopGroup 和 ServerBootstrap。 设置 ServerBootstrap 的属性：线程组、SO_BACKLOG 选项，设置 NioServerSocketChannel 为 Channel，设置业务处理 Handler。 绑定端口，启动服务器程序。 在业务处理 TimeServerHandler 中，读取客户端发送的数据，并给出响应。可以看到，Netty把NIO开发中的很多细节帮我们做了，比如：不需要操作Selector，不需要手动从SocketChannel中读取数据并转换完ByteBuffer等问题，我们只需要考虑业务处理就可以了。从语言描述上体会可能不是很深，你可以点击下方连接查看代码，与之前的JDK NIO代码进行对比，你会更直观的体会出Netty的”简单与快速”。 点击查看Netty NIO完整示例代码 Netty核心组件以下组件目前有个概念即可，后续会有章节单独详细的讲解。下面我们简单的介绍一下Netty中的核心组件： Channel ByteBuf EventLoop Future ChannelPipeline ChannelHandler这些模块代表了不同类型的构建、资源、逻辑及通知，应用程序将使用它们来访问网络以及流经网络的数据。 Channel基本的 I/O 操作(bind()、connect()、read()和 write())依赖于底层网络传输所提 供的原语。在基于 Java 的网络编程中，其基本的构造是 class Socket。Netty 的 Channel 接 口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。此外，Channel 也是拥有许多预定义的、专门化实现的广泛类层次结构的根。下面是一个简短的部分清单: EmbeddedChannel — Netty专门为改进针对ChannelHandler的单元测试的一种特殊Channel实现 LocalServerChannel — Netty提供的用来在同一个JVM内部实现client和server之间通信的transport NioDatagramChannel — Netty提供的UDP数据包的channel NioSctpChannel — 异步的客户端 Sctp 连接 NioSocketChannel ByteBufJava NIO 提供了 ByteBuffer 作为它 的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。Netty 的 ByteBuffer 替代品是 ByteBuf，一个强大的实现，既解决了 JDK API 的局限性， 又为网络应用程序的开发者提供了更好的 API。 EventLoop（Reactor线程组）EventLoop 定义了 Netty 的核心抽象，用于处理连接的生命周期中所发生的事件。 一个 EventLoopGroup 包含一个或者多个 EventLoop; 一个 EventLoop 在它的生命周期内只和一个 Thread 绑定; 所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理; 一个 Channel 在它的生命周期内只注册于一个 EventLoop; 一个 EventLoop 可能会被分配给一个或多个 Channel。 下图为Channel、EventLoop、Thread 以及 EventLoopGroup 之间的关系。 FutureFuture 提供了另一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符;它将在未来的某个时刻完成，并提供对其结果的访问。JDK预置了 interface java.util.concurrent.Future，但是其所提供的实现，只允许手动检查对应的操作是否已经完成，或者一直阻塞直到它完成。这是非常繁琐的，所以 Netty 提供了它自己的实现 ChannelFuture，用于在执行异步操作的时候使用。ChannelFuture提供了几种额外的方法，这些方法使得我们能够注册一个或者多个 ChannelFutureListener实例。监听器的回调方法operationComplete()，将会在对应的 操作完成时被调用。然后监听器可以判断该操作是成功地完成了还是出错了。如果是后者，我们可以检索产生的Throwable。简而言之 ，由ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要。每个 Netty 的出站 I/O 操作都将返回一个 ChannelFuture;也就是说，它们都不会阻塞。 ChannelPipelineChannelPipeline 提供了 ChannelHandler 链的容器，并定义了用于在该链上传播入站和出站事件流的API。ChannelPipeline 它负责ChannelHandler的管理和事件拦截与调度，当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。 ChannelHandlerChannelHandler 它充当了所有 处理入站和出站数据的应用程序逻辑的容器。类似于Servlet的Filter过滤器，负责对I/O事件或者I/O操作进行拦截和处理。ChannelHandler 可以用于任何类型的动作，例如将数据从一种格式转换为另外一种格式，或者处理转换过程中所抛出的异常。]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>并发编程</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty指南（2）--- Java I/O入门]]></title>
    <url>%2Fnetty%2Fnetty-guide-2-io-basic%2F</url>
    <content type="text"><![CDATA[前言本文我们将会介绍Java中的几种网络I/O模型，BIO、伪NIO、NIO、AIO，并提供演示代码。 BIO — 同步阻塞I/O网络编程的本身是两个进程间的相互通信，其中server端提供位置信息（绑定ip及监听端口），客户端通过连接操作向服务器监听的地址发起连接请求，通过三次握手建立连接，如果连接建立成功，双方就可以通过套接字（socket）进行通信。如上图所示，采用BIO通信模型的server端，由一个独立的Acceptor线程负责监听客户端连接，当没有客户端连接时服务端阻塞在accept操作上，在接收到客户端连接请求后为每一个客户端创建一个新的线程进行链路处理，处理完毕后通过输出流返回应答消息给客户端，线程销毁，这就是经典的一应一答通信模型。该模型最大的问题是缺乏弹性伸缩能力，当客户端并发量增大时，服务端的线程个数和客户端的并发访问数呈1：1的关系，由于线程是Java虚拟机比较宝贵的系统资源，随着线程数的继续增大，程序会变得愈发的不稳定，最终会出现 栈溢出、创建新线程失败，进而导致宕机或僵死，无法对外提供服务。 点击查看BIO完整示例代码 伪异步IO — BIO的升级版为了解决BIO中的问题，后端通过在BIO的基础上增加了一个线程池来处理多个客户端的接入，客户端和服务端的关系是 客户端个数M：线程池最大线程数N，由于线程池队列的关系，M可以远大于N，通过线程池可以灵活的调配线程资源，设置最大线程数以防止海量并发连接导致系统资源耗尽。如上图所示，当有新的客户端接入时，将客户端的socket封装成task（该任务需实现java.lang.Runnable接口），由线程池中的空闲线程进行处理，由于线程池可以设置队列大小和最大线程数，所以这种I/O模型占用的系统资源是可控的，无论多少个客户端并发请求都不会导致资源耗尽和宕机。不过要说的是 伪异步I/O 只是BIO一个简单的升级版，官方并没有这种叫法，它只是利用线程池解决了资源占用随着客户端连接数无限增长的问题，但是它无法解决BIO导致的线程阻塞问题。比如：服务器处理缓慢，造成长时间阻塞，如果线程池中的可用线程都被阻塞，那后续所有I/O消息都将在队列中排队，由于线程池采用阻塞队列实现，队列积满后续入队列的操作会被阻塞，进而导致新的客户端被拒绝连接，客户端会发生大量连接超时，这就是一个典型的级联故障。 点击查看伪异步IO完整示例代码 由于伪异步IO，只是BIO的升级版，我称之为BIOPlus~~~，也因此示例代码直接在bio文件夹中创建了bioPlusServer文件夹，并增加了伪异步I/O的server端实现，客户端并没有改动。 NIO — 同步非阻塞I/O首先需要澄清一个概念，NIO到底是什么简称？官方叫法是 NewIO，因为相对之前的I/O类库NIO是新增的，它的目标是让Java支持非阻塞I/O，所以也有很多人称NIO为Non-block IO。它是基于I/O多路复用技术的非阻塞I/O，并不是异步的，NIO类库是JDK1.4中引入的，用来弥补原来的同步阻塞I/O的不足（BIO），有部分人称NIO为异步非阻塞IO，这里所说的”异步”是应用层的异步，系统内核的实现还是同步的。JDK1.4阶段NIO的Selector底层基于select/poll模型实现，到了JDK1.5+ Selector的底层实现被优化，底层使用epoll替换了select/poll，但这只是NIO的性能优化，上层API并没有变化，也没有改变I/O模型，还是同步非阻塞I/O。与BIO中Socket类和ServerSocket类相对应，NIO提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现，这两种新增的通道都支持阻塞和非阻塞两种模式。阻塞模式使用非常简单，但是性能和可靠性不好，一般来说，低负载、低并发的应用程序可以选择阻塞I/O以降低程序复杂度，对于高负载、高并发的应用需要使用NIO的非阻塞模式。NIO中客户端的连接操作和SocketChannel的读写操作都是异步的，如果没有可读写数据会直接返回，可以通过在Selector上注册OP_CONNECT等待后续结果，这样I/O通信线程就可以处理其他的链路，不需要像BIO那样被同步阻塞。因为NIO中的Selector底层实现所使用的的I/O多路复用本质上都属于就是同步I/O，我们需要主动去轮询就绪Channel并根据其状态来进行对应的I/O操作。 点击查看NIO完整示例代码 NIO类库中多了很多新增的功能和概念，下面我们来介绍一下 Buffer — 缓冲区Buffer是NIO中新增的一个对象，它包含一些要写入或者读出的数据，在NIO库中所有的数据都是用Buffer处理的，任何时候访问NIO中的数据都要通过Buffer进行操作，Buffer其本质是一个数组，但功能远比数组强大，它提供了对数据的结构化访问及维护读写位置等信息。最常用的缓冲区是ByteBuffer，用于操作byte[]，Java中除了Boolean类型，其他的基本类型都对应着一种缓冲区，如：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。每个Buffer类都是Buffer接口的一个实例，除了ByteBuffer，其他类型的Buffer操作都一样，只是操作的数据类型不同而已，由于绝大多数标准I/O操作都使用ByteBuffer，所以ByteBuffer在具有和其他类型一样的操作之外，还提供了特有的操作，用来方便网络读写。 Channel — 通道Channel是一个通道，网络数据通过Channel读取和写入，通道Channel与流Stream之间的区别是通道是双向的，流只能在一个方向移动，要么是输入InputStream要么是输出OutputStream，而通道既可以用来读数据也可以用来写数据，也可以同时进行。Channel是全双工通道，更好的体现了底层操作系统的API，在Unix网络编程模型中，底层操作系统的通道都是全双工的，同时支持读写操作。 Selector — 多路复用器/选择器Selector是Java NIO编程的基础，熟练的掌握Selector对于NIO编程至关重要，多路复用器提供选择已经就绪的任务的能力，简单来说就是Selector会不断轮训注册在其上的Channel，如果某个Channel上面发生读写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续I/O操作。一个Selector可以同时轮询多个Channel，由于JDK使用了epoll()代替传统的select实现，所以它并没有最大连接句柄的限制，这也就意味着只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。 AIO — 异步非阻塞I/ONIO2.0引入的新的异步通道的感念，对应UNIX网络I/O模型中的异步IO模型，也就是AIO，它提供了异步文件通道和异步套接字通道的实现，CompletionHandler接口的实现类作为操作完成的回调。它不需要像NIO编程那样创建一个独立的I/O线程处理读写事件，也不需要对注册的Channel进行轮询操作即可实现异步读写，从而大大简化了NIO的编程模型。AIO的Socket操作都是由JDK底层线程池负责回调并驱动读写操作，所以使用AIO的异步非阻塞Channel进行编程比NIO变成更为简单。 点击查看AIO完整示例代码]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>并发编程</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty指南（1）--- I/O模型介绍]]></title>
    <url>%2Fnetty%2Fnetty-guide-1-io-model%2F</url>
    <content type="text"><![CDATA[前言本文我们将会介绍JavaI/O进化过程、Linux系统中网络编程I/O的五种模型，以及I/O多路复用技术。 JavaI/O发展史众所周知Netty是由Java开发，那我们先简单的聊聊Java。Java是由Sun Microsystems公司1995年发布的一款高级编程语言，由于其拥有 一次编写、到处运行 的特性和丰富且强大的第三方类库支持，自发布以来应用极其广泛，但是Java早期的功能并不完善，其中最令人恼火就是基于同步I/O的Socket通信类库，因为对于操作系统而言，底层是支持异步I/O通信的，只不过很长一段时间Java并没有提供异步I/O通信的类库，JDK1.0 ~ JDK1.3期间Java的IO类库都非常原始，很多Unix网络编程中的接口在Java的I/O类库中都没有体现，例如Pipe、Channel、Buffer、Selector等。 Java早期I/O(&lt;1.4)的一些明显问题（包括但不限于） 没有C/C++中Channel的概念，只有输入和输出流 同步阻塞式通信I/O，当并发量变大时，经常会导致线程被长时间阻塞且占用资源大 没有数据缓冲区，I/O性能相对较差直到2002年随着JDK1.4的发布Java才第一次支持非阻塞I/O，这个类库的提供为JDK的通信模型带来了巨大的变化。JDK1.4新增主要的类/接口如下 异步IO操作的缓冲区ByteBuffer 进行异步IO操作的管道Pipe 进行IO操作的Channel，包括ServerSocketChannel和SocketChannel 文件通道FileChannel 多种字符集编解码能力 实现非阻塞IO操作的多路复用器Selector 基于Perl实现的正则表达式类库等……新的NIO类库的提供极大地促进了Java异步非阻塞编程的发展和应用，但仍有不完善的地方。早期NIO类库主要问题如下 没有统一的文件属性，例如读写权限 API能力比较弱，例如目录的联级创建和递归遍历，往往需要自己实现 底层存储系统的一些高级API无法使用 所有文件操作都是同步阻塞调用的，不支持异步文件读写操作2011年，JDK1.7正式发布，最大的亮点是NIO类库的升级，NIO2.0（AIO诞生）。主要提供如下改进 提供能够批量获取文件属性的API，这些API具有平台无惯性，不与特定的文件系统耦合 提供AIO功能，支持基于文件和网络套接字的异步操作 Linux网络I/O模型Linux内核对外部设备都看作一个文件来操作，一个文件的读写操作会调用内核命令，返回一个文件描述符-fd，对于socket的读写也会有相应的描述符-socketfd，它指向内核中的一个结构体。根据Unix网络编程对I/O模型的分类，共分为5种I/O模型，分别如下： 同步阻塞I/O模型最常用的I/O模型，所有文件操作都是阻塞的，以套接字接口为例，在用户进程空间调用recvfrom(用于套接口上接收数据，并捕获数据发送源的地址)，其系统调用直到数据包到达且数据包被复制到用户进程的缓冲区或发生错误时才返回，在此期间会一直处于阻塞状态，因此被称为阻塞I/O模型。 同步非阻塞I/O模型继续以上面的套接字接口为例，在用户进程空间中调用recvfrom，从应用层到内核的时候，有数据直接返回，没数据会返回一个EWOULDBLOCK错误，一般都会对非阻塞I/O进行状态轮训，看内核中有没有数据过来。 I/O复用模型Linux提供了select、poll，进程通过一个或多个文件描述符-fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个fd是否处于就绪。select和poll的实现方式类似，不同之处在于select有fd的限制，poll采用pollfd链式结构代替select中fd_set使其没有fd数量的限制，但是其内部实现都是顺序扫描所有fd的状态，并且每次调用select/poll都需要把fd集合从用户空间copy到内核空间，因此当连接数变大处理速度会呈线性下降，因此它的使用受限。Linux还提供了一个epoll系统调用，epoll为每个fd指定了一个回调函数，当数据准备好后，就绪的fd会主动加入到一个就绪队列中，唤醒就绪fd的等待者，调用回调函数。epoll使用基于事件驱动方式代替select/poll中的顺序扫描，因此性能提高很多。 信号驱动I/O模型信号驱动IO模型的特点是无需等待数据，在数据等待阶段是非阻塞的，内核当数据准备就绪时会为该进程生成一个SIGIO信号，应用程序只需要绑定SIGIO信号的处理函数就可以了，通过SIGIO信号回调通知应用程序来读取数据，并通知”属主”进程执行SIGIO信号处理函数处理数据。信号驱动I/O模型因为其无需等待数据就绪的特性，比select和poll的性能高，但是缺点是致命的，Linux中信号队列的大小是有限制的，一旦队列溢出，进程将终止导致无法读取数据。 异步I/O模型告知内核启动某个操作，并让内核在整个操作后（包括将数据从内核复制到用户缓冲区）通知我们。这种模型与信号驱动模型主要区别是 信号驱动IO由内核通知我们何时开始一个I/O操作，异步I/O模型由内核通知我们IO操作何时已经操作完成。 IO多路复用技术在IO编程过程中，当需要同时处理多个客户端接入请求时可以利用多线程或I/O多路复用技术进行处理。I/O多路复用技术通过把多个IO的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统多线程/多进程相比，IO多路复用的优势在于系统开销小，系统不需要创建新的额外进程/线程，也不需要维护这些进程/线程的运行，降低了系统维护的工作量同时也节省了系统资源。目前支持的I/O多路复用系统调用有select、pselect、poll、epoll，在Linux网络编程过程中，很长一段时间都使用select做轮训和网络事件通知，由于select的固有缺陷，导致它的应用受到了很大的限制，最终Linux在新的内核版本中选择了epoll。 epoll与select相比 支持一个进程打开的socket描述符-fd不受限制(仅受限于操作系统的最大文件句柄数) select最大的缺陷是单个进程所能打开的fd有限制，它由FD_SETSIZE设置，缺省值是1024，对于那些需要支持成千上万个TCP连接的服务器显然太少了，可以选择修改这个宏重新编译内核，不过会带来网络效率下降的问题。也可以使用传统的多进程方案解决这个问题，虽然在Linux中创建进程的代价比较小，但随着连接数的增加资源占用还是会线性增长，所以这种方式并不能解决根本问题。epoll并没有这个限制，它所支持的fd上限是系统可创建的最大文件句柄数，要远远大于select中的FD_SETSIZE，比如一台1GB的机器上可以创建10W个句柄左右，具体的只可以通过Linux系统命令 cat /proc/sys/fs/file-max 查看系统最大文件句柄数，通常这个值与系统的内存关系比较大，可人为根据实际机器配置情况修改这个值。 IO效率不会随着fd的数量增加而线性下降 传统select/poll的一个致命缺点是当拥有一个很大的socket集合时，由于网络延时或链路空闲，任一时刻只有少部分的socket是活跃的，但是select/poll每次调用都会线性扫描全部的集合，导致效率成线性下降。epoll中不存在这个问题，它只会对活跃的socket进行操作，这是因为在内核实现中epoll是根据每个fd的callback函数实现的，只有活跃的socket才会主动调用callback函数，其他idle状态的socket则不会，这也是为什么有人称epoll为”异步IO”。针对epoll和select性能对比的benchmark测试表明：如果所有的socket都处于活跃状态，在这种情况下epoll的效率并不比select/poll高，反而有些许下降，但是正常的网络环境参差不齐，socket基本不会全部处于活跃状态，在这种情况下epoll的性能远高于select/poll。 使用mmap加速内核与用户控件的消息传递 无论是select、poll还是epoll都需要内核把fd消息通知给用户空间，如何避免不必要的内存复制是非常重要的。epoll是通过内核和用户控件mmap同一块内存来实现的，避免了不必要的内存复制。 补充说明 克服select/poll缺点的方法不只有epoll，epoll只是Linux的实现方案，在freeBSD（另外一种操作系统）中的kqueue同样可以克服select/poll的缺点，但是使用难度较高，而且我们的应用程序目前绝大多数都是部署在Linux中的。]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>并发编程</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java代码混淆之Allatori]]></title>
    <url>%2FdevelopTool%2Fallatori%2F</url>
    <content type="text"><![CDATA[前言Allatori是一个Java 混淆器,它属于第二代的混淆器，因此它能够全方位的保护你的知识产权。Allatori完全使用java编写，所以可以运行java代码的环境，都可以使用Allatori。Allatori具有以下几种保护方式：命名混淆，流混淆，调试信息混淆，字符串混淆，以及水印技术。对于教育和非商业项目来说这个混淆器是免费的。新版本支持war和ear文件格式，并且允许对需要混淆代码的应用程序添加有效日期。点此查看官方文档 为什么要混淆代码？Java是一种跨平台的、解释型语言，Java源代码编译成中间“字节码”存储于class文件中。由于跨平台的需要，Java字节码中包括了很多源代码信息，如变量名、方法名，并且通过这些名称来访问变量和方法，这些符号带有许多语义信息，很容易被反编译成Java源代码。为了防止这种现象，我们可以使用Java混淆器对Java字节码进行混淆。 什么是名称混淆？Allatori的名称混淆机制将有意义的类，字段、方法名称更改为无意义的字符串。虽然Allatori是第二代Java混淆器，但它也可以执行出色的名称混淆。与其他一些混淆器不同，它被设计为处理任何类型的依赖和继承方案。Allatori生成的新名称非常短，因此它减少了字节代码的大小。在名称混淆的字节代码中，包，类，字段和方法名称已重命名，并且永远不能恢复原始名称。不幸的是，控制流程仍然清晰可见。这就是为什么我们还需要使用Allatori的Flow Obfuscation（流混淆）。 什么是流混淆？Allatori作为第二代Java混淆器，除了名称混淆之外，还执行流混淆。比如使用了 ‘if’，’switch’，’while’或’for’ 等关键字的方法，会被进行执行流混淆。它对字节码做了细微的修改，模糊了控制流，而不改变代码在运行时的行为。通常情况下，选择和循环等逻辑构造会被更改，因此它们不再具有直接等效的Java源代码。流模糊的字节码通常强制反编译器将一系列标签和非法的“goto”语句插入到它们生成的源代码中。源代码有时会因为反编译错误而变得更加模糊。 什么是调试信息混淆？Allatori使用所有“传统”混淆技术。它会混淆调试信息并重命名所有可能的方法和字段名称。我理解的是Allatori混淆了执行流和类、方法的名称后就达到了调试信息混淆，因为混淆后的代码无法与源代码相对应。 什么是字符串混淆？当竞争对手或黑客反编译混淆的应用程序时，他们会寻找任何他们感兴趣的信息。比如嵌入在应用程序中的字符串文字提供了重要的线索。这些文字可能是：1.调试程序需要的输出。2.错误消息的文本。3.异常消息的文本。在代码中对字符串的简单搜索将会显示其使用位置的确切位置，这意味着它将本地化​​必要的代码片段，从而使黑客更容易理解算法你的程序。字符串文字可以成为探索整个应用程序的起点。Allatori的字符串加密技术对存储在类文件的常量池中的字符串字面值进行加密。在这种情况下，应用程序反编译后的字符串搜索不会给黑客带来任何好处。Allatori将代码片段添加到类中，以便您的字符串在运行时被解密，这意味着表面上一切都将如常。 什么是软件水印？软件水印可以用于将客户标识或版权信息隐藏到软件应用程序中，类似于使用隐写技术将其隐藏在诸如歌曲，电影和图像之类的其他数字内容中。水印可用于识别软件的所有者或跟踪盗版副本的来源。 混淆器的优势混淆就是对发布出去的程序进行重新组织和处理，使得处理后的代码与处理前代码完成相同的功能，而混淆后的代码很难被反编译，即使反编译成功也很难得出程序的真正语义。被混淆过的程序代码，仍然遵照原来的档案格式和指令集，执行结果也与混淆前一样，只是混淆器将代码中的所有变量、函数、类的名称变为简短的英文字母代号，在缺乏相应的函数名和程序注释的况下，即使被反编译，也将难以阅读。同时混淆是不可逆的，在混淆的过程中一些不影响正常运行的信息将永久丢失，这些信息的丢失使程序变得更加难以理解。混淆器的作用不仅仅是保护代码，它也有精简编译后程序大小的作用。由于以上介绍的缩短变量和函数名以及丢失部分信息的原因， 编译后jar文件体积大约能减少25% ，这对当前费用较贵的无线网络传输是有一定意义的。 Allatori的使用下载支持包Allatori不需要安装，你需要在官网下载它的支持包。下载后的包解压后它长这个样子。它包含allatori的支持包，它在lib目录下，还有allatori的使用教程。我们需要的是lib中的两个jar包，将它放到我们的工程目录中，这里使用maven 构建，你可以选择把它放到项目的根目录中。 编写allatori配置文件在项目中新建一个allatori.xml文件，位置和名称不是固定的，看你心情。以下是配置文件的内容。12345678910111213141516171819202122232425262728293031323334&lt;config&gt; &lt;input&gt; &lt;jar in="allatori-1.0-SNAPSHOT.jar" out="new-allatori-1.0-SNAPSHOT.jar"/&gt; &lt;/input&gt; &lt;classpath&gt; &lt;jar name="/Users/choice/.m2/repository/**/*.jar"/&gt; &lt;/classpath&gt; &lt;expiry date="2000/01/01" string="EXPIRED!"/&gt; &lt;keep-names&gt; &lt;class template="class * instanceof java.io.Serializable"/&gt; &lt;class template="class * instanceof java.io.Serializable"&gt; &lt;field template="static final long serialVersionUID"/&gt; &lt;method template="void writeObject(java.io.ObjectOutputStream)"/&gt; &lt;method template="void readObject(java.io.ObjectInputStream)"/&gt; &lt;method template="java.lang.Object writeReplace()"/&gt; &lt;method template="java.lang.Object readResolve()"/&gt; &lt;/class&gt; &lt;class access="protected+"&gt; &lt;field access="protected+"/&gt; &lt;method access="protected+"/&gt; &lt;/class&gt; &lt;/keep-names&gt; &lt;property name="log-file" value="log.xml"/&gt; &lt;ignore-classes&gt; &lt;class template="class *springframework*" /&gt; &lt;/ignore-classes&gt;&lt;/config&gt; 配置文件中的内容下面会一一讲解。 添加Allatori的maven配置将以下内容添加到 pom.xml 中。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;build&gt; &lt;plugins&gt; &lt;!-- 配置你项目的编译方式 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- Allatori config 将Allatori配置文件复制到“目标”目录。目标文件将被过滤(配置文件中使用的Maven属性将被解析)。--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-and-filter-allatori-config&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;basedir&#125;/target&lt;/outputDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;basedir&#125;/allatori&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;allatori.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- Running Allatori --&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.6.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;run-allatori&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;exec&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;executable&gt;java&lt;/executable&gt; &lt;arguments&gt; &lt;argument&gt;-Xms128m&lt;/argument&gt; &lt;argument&gt;-Xmx512m&lt;/argument&gt; &lt;argument&gt;-jar&lt;/argument&gt; &lt;argument&gt;$&#123;basedir&#125;/../lib/allatori.jar&lt;/argument&gt; &lt;argument&gt;$&#123;basedir&#125;/target/allatori.xml&lt;/argument&gt; &lt;/arguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- Allatori plugin end --&gt; &lt;/plugins&gt;&lt;/build&gt; 常用的Allatori标签以下是常用的配置标签，如想看完整的标签，请查看官网文档 config –&gt; input taginput 标签是用来设置混淆源（JAR，WAR，EAR）文件。 它应该包含至少一个嵌套的jar或dir标记来设置输入和输出文件。 input 标签有两个可选属性： basedir 可选属性。将根据指定的目录解析jar文件的相对路径。默认情况下，将根据配置文件位置解析相对路径。 single-jar 可选属性。Allatori将创建一个包含所有混淆类的附加输出jar文件。 config –&gt; input –&gt; jar tagjar标签有两个必需的属性： in 要混淆的jar文件的名称。 out 输出jar文件的名称。它可以与in相同，在这种情况下，jar将被其混淆版本覆盖。 config –&gt; classpath tagclasspath 标签是用来设置的类路径混淆应用。 它包含带有jar文件名称的嵌套jar标签。 没有必要引用应用程序所需的所有库jar，但缺少类路径元素可能会导致模糊处理较弱。 Allatori会在混淆过程中警告你所有缺失的class。 classpath 标签有一个可选属性： basedir 将根据指定的目录解析jar文件的相对路径。默认情况下，将根据配置文件位置解析相对路径。 config –&gt; classpath –&gt; jar tagclasspath 中的 jar标签有一个必需属性： name 要添加到类路径的jar文件的名称。 允许使用通配符语法：“*”匹配文件名中的任何字符; “**”递归到子目录。 config –&gt; expiry tagexpiry 标记用于到期日设置为你的应用程序。 有效期限检查被插入到许多方法中，而不仅仅是主要方法，因此不能轻易删除。 此功能可用于混淆甚至没有主方法的库。 expiry 标签有两个必需的属性： date 必需的。有效期为yyyy/mm/dd格式。 string 必需的。如果应用程序在指定的过期日期之后运行，则抛出异常的任何字符串消息。 config –&gt; keep-names tagkeep-names 标签用于设置不应该在混淆过程被重新命名类，方法和字段名。 如果混淆的应用程序是库，那么您应该保留所有公共API。 对于独立应用程序，您应至少保留主类的名称。 您还应该保留通过反射使用的类和方法的名称。 keep-name 有下列嵌套的标签： field 用于指定不重命名的范围。 method 用于指定不应重命名的方法; class 用于指定不应重命名的类。反过来，可以包含嵌套的字段和方法标记。 config –&gt; keep-names –&gt; class tagclass 标签用于匹配的类。 class 它具有以下属性： access 设置匹配规则，如下： private 匹配具有 private 访问权限的类，字段或方法。 private+ 匹配具有 private 或更高访问权限的类，字段或方法。 package 使用包访问匹配类，字段或方法。 package+ 匹配包及子包的类，字段或方法。 protected 匹配具有 protected 访问权限的类，字段或方法。 protected+ 匹配具有 protected 或更改访问权限的类，字段或方法。 public 匹配具有 public 访问权限的类，字段或方法。 template 设置匹配规则。如下： class * 匹配所有类和接口。 interface * 匹配所有接口。 public class * 匹配所有public的类和接口。 protected+ class * 匹配所有protected的类和接口。 class *abc* 匹配以完全限定名包含“abc”的所有类。 class com.abc.* 匹配com.abc包及其子包中的所有类。 class *.abc.* 匹配所有“abc”包及其子包中的所有类。 class * extends java.util.Enumeration 匹配所有继承java.util.Enumeration的所有类。 class * extends *.Enumeration 匹配所有继承*.Enumeration的类。 class * instanceof java.io.Serializable 匹配作为java.io.Serializable实例的所有类。 class * implements *.MouseListener 匹配实现MouseListener的所有类。 @java.lang.Deprecated class * 匹配所有已弃用的类。 ignore 如果设置为“true”或“yes”，则将重命名匹配的类，但将像往常一样处理嵌套的方法和字段标记。 它允许保留某些字段和方法的名称，而不保留类的名称。 stop 如果设置为“true”或“yes”，则Allatori将停止对匹配的类应用任何进一步的规则。 config –&gt; keep-names –&gt; class –&gt; field tagfield 该标签用于匹配字段。 field 标签具有以下属性： access属性设置匹配规则，如下： private 匹配具有 private 访问权限的类，字段或方法。 private+ 匹配具有 private 或更高访问权限的类，字段或方法。 package 使用包访问匹配类，字段或方法。 package+ 匹配包及子包的类，字段或方法。 protected 匹配具有 protected 访问权限的类，字段或方法。 protected+ 匹配具有 protected 或更高访问权限的类，字段或方法。 public 匹配具有 public 访问权限的类，字段或方法。 template属性具有以下格式： * 匹配所有字段。 private * 匹配所有私有字段。 private+ * 匹配所有字段。 protected+ * 匹配所有受保护和公共字段。 static * 匹配所有静态字段。 public static * 匹配所有公共静态字段。 public int * 匹配所有公共整数字段。 java.lang.String * 匹配所有String字段。 java.lang.* * 匹配java.lang包中所有类型的字段。 abc* 匹配名称以“abc”开头的所有字段。 private abc* 匹配名称以“abc”开头的所有私有字段。 * instanceof java.io.Serializable 匹配所有可序列化的字段。 @java.lang.Deprecated * 匹配所有已弃用的字段。 config –&gt; keep-names –&gt; class –&gt; method tagmethod 标签用于匹配的方法。 如果 method 标签嵌套在 class 标签中，则它仅应用于父类标记匹配的类。 如果父标记是 keep-names，则它将应用于所有类。 method 标签具有以下属性： access 设置匹配规则，规则同行 access 属性 method标签的template属性具有以下格式： [@annotation] [modifiers] [type] methodname（arguments） template *(**) 匹配所有方法。 private *(**) 匹配所有私有方法。 private+ *(**) 匹配所有方法。 protected+ *(**) 匹配所有受保护和公共方法。 private+ *(*) 只用一个参数匹配所有方法。 private+ *(*,*) 使用两个参数匹配所有方法。 private+ *(java.lang.String) 使用String类型的一个参数匹配所有方法。 private+ *(java.lang.String,**) 使用String匹配所有方法作为第一个参数。 private+ *(java.lang.*) 匹配所有方法只有一个参数，类型在java.lang包中。 public get*(**) 匹配名称以“get”开头的所有公共方法。 public *abc*(**) 匹配名称包含“abc”的所有公共方法。 private+ int *(**) 匹配int返回类型的所有方法。 @java.lang.Deprecated *(**) 匹配所有已弃用的方法。 parameters 如果设置为“keep”，则不会更改方法参数的名称。对公共API方法很有用。 config –&gt; ignore-classes tagignore-classes标签用于从混淆过程中完全排除一些类。 这些类是“原样”复制的，对输出jar文件没有任何更改。 注意，被忽略的类将引用其他类的原始名称,不能重命名被忽略类引用的类/方法。 config –&gt; ignore-classes –&gt; class tag与 config --&gt; ignore-classes --&gt; class tag 中的规则相同。 config –&gt; property tagproperty 标签用于设置不同的混淆属性。 property 标签有两个必需的属性 name 和 value： 普通属性 log-file filename Allatori将把混淆日志写入指定的文件。如果没有设置属性，则不会创建日志文件。 相对路径根据配置文件位置进行解析。 随机种子 random-seed any string 用于初始化随机数生成器的字符串。 字符串加密属性 string-encryption enable (默认情况下)所有可以安全更改加密值的字符串字面值都将被加密。 Allatori将在运行时添加一个方法来解密字符串。 disable 字符串加密被禁用。 maximum 所有字符串文字将被加密。请参阅下面的限制。 maximum-with-warnings 所有字符串文字都将被加密。 使用==运算符的每个字符串比较都会产生警告，您将能够用equals（）调用替换这些比较。 string-encryption-type fast (默认)Allatori将使用非常快的字符串加密算法。 strong Allatori将使用强大和棘手的字符串加密算法,不过，速度要慢一些。 控制流混淆属性 control-flow-obfuscation enable Allatori将修改方法的代码。它不会在运行时改变应用程序的行为，但会使反编译过程更加困难。 通常，控制流混淆也使应用程序更小、更快。 disable 控制流混淆被禁用。 extensive-flow-obfuscation normal (默认情况下)Allatori将使用控制流混淆技术，这将使混乱的应用程序变得更大、更慢。 然而，Allatori将最小化此类代码转换的数量。 disable 禁用广泛的控制流混淆。 maximum Allatori将完全使用控制流混淆技术，这使得混淆应用程序变得更大、更慢。 混淆前后效果混淆前12345678910111213141516171819202122232425public class App &#123; public App() &#123; &#125; public static void main(String[] args) &#123; System.out.println("Hello World!"); Integer aaaaaaa = 127; Integer aaaaaaa1 = 127; System.out.println(aaaaaaa == aaaaaaa1); Integer bbbbbbb = 128; Integer bbbbbbb1 = 128; System.out.println(bbbbbbb == bbbbbbb1); int score = 10; if (score &gt;= 60) &#123; System.out.println("及格"); &#125; else if (score &gt;= 80) &#123; if (score &lt; 85) &#123; System.out.println("良好"); &#125; else if (score &gt;= 85) &#123; System.out.println("优秀"); &#125; &#125; &#125;&#125; 混淆后1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class App &#123; public App() &#123; &#125; public static String ALLATORIxDEMO(String s) &#123; int var10000 = 5 &lt;&lt; 4 ^ 3 &lt;&lt; 2 ^ 3; int var10001 = (2 ^ 5) &lt;&lt; 4 ^ 2 &lt;&lt; 2 ^ 3; int var10002 = 4 &lt;&lt; 4 ^ 4 &lt;&lt; 1; int var10003 = s.length(); char[] var10004 = new char[var10003]; boolean var10006 = true; int var5 = var10003 - 1; var10003 = var10002; int var3; var10002 = var3 = var5; char[] var1 = var10004; int var4 = var10003; var10000 = var10002; for(int var2 = var10001; var10000 &gt;= 0; var10000 = var3) &#123; var10001 = var3; char var6 = s.charAt(var3); --var3; var1[var10001] = (char)(var6 ^ var2); if (var3 &lt; 0) &#123; break; &#125; var10002 = var3--; var1[var10002] = (char)(s.charAt(var10002) ^ var4); &#125; return new String(var1); &#125; public static void main(String[] var0) &#123; System.out.println(ALLATORIxDEMO("qkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXBXh[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[kqk[h[h[h[hXk[k[h[k[h[hXk[kXk[kXk[kXh[kXk[h[h[h[hXBXh[h[h[hXhXhXh[hXh[hXhXh[k[hXhXhXhXh[k[h[h[h[h[kqk[h[h[h[kXk[k[h[k[h[kXk[hXh[k[k[kXh[hXh[h[h[h[hXBXh[h[h[hXhXhXkXhXkXhXhXh[k[hXkXhXhXhXkXh[h[h[h[kqk[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[hXBXh4*\u001d=\b+\u001a&lt;\u0012'\u0015h\u00191[\t\u0017$\u001a&lt;\u0014:\u0012h4*\u001d=\b+\u001a&lt;\u0014:[&gt;MfMh?\r6\u0007[kqk[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[hXBXh[h[h[h[h[h\u0013&lt;\u000f8AgT?\f?U)\u0017$\u001a&lt;\u0014:\u0012f\u0018'\u0016h[h[h[h[h[h[kqk[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[h[hXBXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkXkq")); System.out.println(ALLATORIxDEMO("\u0000\u001e$\u0017'[\u001f\u0014:\u0017,Z")); Integer a = 127; Integer a = 127; System.out.println(a == a); Integer a = 128; Integer a = 128; System.out.println(a == a); int a = 10; if (10 &gt;= 60) &#123; System.out.println(ALLATORIxDEMO("厂桇")); &#125; else &#123; if (a &gt;= 80) &#123; if (a &lt; 85) &#123; System.out.println(ALLATORIxDEMO("舧夆")); return; &#125; if (a &gt;= 85) &#123; System.out.println(ALLATORIxDEMO("佐离")); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>java代码混淆</tag>
        <tag>allatori</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm2 + ohMyZsh 打造Mac完美终端]]></title>
    <url>%2FdevelopTool%2Fiterm2-ohmyshell%2F</url>
    <content type="text"><![CDATA[前言作为码农，大家对Terminal都很熟悉，如果你使用的是Mac，那么MacOS自带的Terminal可能会让你失望。下面我们一步一步的搭建一个 功能强大、智能、美观 的Terminal。 iTerm2iTerm2是Terminal的替代品，是一款比较小众的软件，功能完爆MacOS的Terminal。iTerm2可以设置主题，支持屏幕切割、各种快捷键。 iTerm2安装使用Bower安装如果已经安装了Bower跳过第一条命令。12npm install bower -gbrew cask install iterm2 官网下载安装点击进入iTerm2官网，下载后直接安装即可。 iTerm2常用配置设置iTerm2为默认Terminal 设置iTerm2打开快捷键 设置iTerm2透明度 设置iTerm2主题配置如果系统主题不合你的胃口，你可以自定义或者导入开源的配色方案。博主使用的是iTerm2-Color-Schemes，在这里面选择一个你喜欢的，或者你也可以使用其他开源的配色方案，不推荐使用需要修改字体的配色方案（虽然很炫）。 配色方案导入 下载iTerm2-Color-Schemes 点击上图中的import，在iTerm2-Color-Schemes目录下的schemes目录里面找到一个你喜欢的配色方案。 iTerm2常用功能及快捷键鼠标选中即复制在iterm2中，选中某个路径或者某个词汇，那么选中内容会被自动复制。 屏幕切割/分屏command+d：垂直分割；command+shift+d：水平分割 全屏切换command+enter 进入与返回全屏模式 常用快捷键新建标签：command + t关闭标签：command + w切换标签：command + 数字 / command + 左右方向键切换全屏/窗口：command + enter查找：command + f垂直分屏：command + d水平分屏：command + shift + d切换屏幕：command + option + 方向键查看历史命令：command + ;查看剪贴板历史：command + shift + h清屏：command + r上一条命令：ctrl + p删除当前光标的字符：ctrl + d删除光标之前的字符：ctrl + h删除光标之前的单词：ctrl + w删除到文本末尾：ctrl + k交换光标处文本：ctrl + t ohMyZshshell的类型有很多种，linux下默认的是bash，虽然bash的功能已经很强大，bash的提示功能不够强大，界面也不够炫，并非理想工具。而zsh的功能极其强大，但配置非常繁琐，于是一个实在忍受不了zsh繁琐配置的程序员发起了一个名为oh-my-zsh的开源项目 ohMyZsh安装/更新安装命令（下面任选其一执行）12sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"sh -c "$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 更新命令1upgrade_oh_my_zsh ohMyZsh切换查看当前使用的shell1echo $SHELL 查看已安装的shell1cat /etc/shells 切换成zsh1chsh -s /bin/zsh ohMyZsh自动补全执行以下命令将自动补全插件clone到oh-my-zsh的插件目录。下面命令不需要更改可以直接执行，目录是读取的环境变量。1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 修改ohMyZsh配置文件1vim ~/.zshrc 将.zshrc文件中plugins=(git) 修改为 plugins=(zsh-autosuggestions git)，重启iTerm2 ohMyZsh语法高亮安装zsh语法插件1brew install zsh-syntax-highlighting 修改ohMyZsh配置文件1vim ~/.zshrc 最后一行增加如下配置1source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 然后重新加载ohMyZsh配置文件1source ~/.zshrc 扩展推荐大家一个很好用的软件，Go2Shell，它可以直接在文件夹中打开Terminal。 Go2Shell安装可以在官网下载，或者AppStore搜索Go2Shell Go2Shell配置安装完成后，执行以下命令会弹出窗口,选择你要用的Terminal然后保存并退出。1open -a go2shell --args config 然后在应用程序目录按住command的同时用鼠标把图标拖放到Finder工具栏然后在Finder中就可以直接点击Go2Shell的图标进入到对应的目录的Terminal。]]></content>
      <categories>
        <category>Mac工作台</category>
      </categories>
      <tags>
        <tag>iTerm2</tag>
        <tag>ohMyZsh</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之队列]]></title>
    <url>%2FdataStructure%2FdataStructure-queue%2F</url>
    <content type="text"><![CDATA[什么是队列(queue)队列（queue）是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，在具体应用中通常用链表或者数组来实现。和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）点击这里查看博客对应的完整代码 非循环队列（普通队列）非循环队列是最简单的队列，使用动态数组/数组实现，大小是固定的，虽然使用数组作为队列的存储结构，但是在队列中只操作头尾节点，所以插入（入队）和查找（出队）都很快。非循环队列的缺点是可能会出现”假溢出”的情况。下面是一个非循环队列的实现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define MAX_QSIZE 5 // 最大队列长度// 队列的数据类型typedef int Q_Data;// 队列的存储结构struct Queue &#123; Q_Data Array[MAX_QSIZE]; // 阵列空间大小 int front; // 队头 int rear; // 队尾 int length; // 队列长度&#125;;// 构造一个空队列QQueue* Q_Init() &#123; Queue *Q = (Queue*)malloc(sizeof(Queue)); if (!Q)&#123; // 存储分配失败 exit(OVERFLOW); &#125; //初始化 Q-&gt;front = Q-&gt;rear = Q-&gt;length = 0; return Q;&#125;// 将Q清为空队列void Q_Clear(Queue *Q) &#123; //清除头尾下标和长度 Q-&gt;front = Q-&gt;rear = Q-&gt;length = 0;&#125;// 入列Q_Data Q_Put(Queue *Q, Q_Data x) &#123; //如果当前元素数量等于最大数量 返回 -1 if (Q-&gt;rear == MAX_QSIZE) return -1; Q-&gt;Array[Q-&gt;rear] = x; Q-&gt;rear++; //length + 1 Q-&gt;length++; return 1;&#125;// 出列Q_Data Q_Poll(Queue *Q,Q_Data &amp;e) &#123; //如果当前元素数量等于最大数量 返回 -1 if (Q-&gt;front == MAX_QSIZE) return -1; e = Q-&gt;Array[Q-&gt;front]; Q-&gt;front++; // 移出后減少1 Q-&gt;length--; return 1;&#125; 循环队列 循环队列可以更简单防止”假溢出”的发生，但队列大小是固定的，使用动态数组/数组实现，相对单链队列来说，插入（入队）和查找（出队）都很快。这里说的循环是逻辑上的循环，体现在入队（put）出队（poll）的操作上面，比如长度是10，队列的头尾指针会始终在0 ～ 9之间循环，也就永远不会出现溢出的情况，因此称为循环队列。循环队列中的循环是以舍弃队列中一个元素空间来达成的，也就是循环队列最大能存储maxSize - 1个元素，比如最大长度是10，那么只能保存9个元素到队列中。下面是一个循环队列的实现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 队列的顺序存储结构(循环队列)#define MAX_QSIZE 6 // 最大队列长度+1// 队列的数据类型typedef int Q_Data;typedef struct &#123; Q_Data *data; // 初始化的动态分配存储空间 int front; // 头指针，若队列不空，指向队列头元素 int rear; // 尾指针，若队列不空，指向队列尾元素的下一个位置&#125; SqQueue;// 构造一个空队列QSqQueue* Q_Init() &#123; SqQueue *Q = (SqQueue*)malloc(sizeof(SqQueue)); // 存储分配失败 if (!Q)&#123; exit(OVERFLOW); &#125; Q-&gt;data = (Q_Data *)malloc(MAX_QSIZE * sizeof(Q_Data)); // 存储分配失败 if (!Q-&gt;data)&#123; exit(OVERFLOW); &#125; Q-&gt;front = Q-&gt;rear = 0; return Q;&#125;// 销毁队列Q，Q不再存在void Q_Destroy(SqQueue *Q) &#123; if (Q-&gt;data) free(Q-&gt;data); Q-&gt;data = NULL; Q-&gt;front = Q-&gt;rear = 0; free(Q);&#125;// 将Q清为空队列void Q_Clear(SqQueue *Q) &#123; Q-&gt;front = Q-&gt;rear = 0;&#125;// 若队列Q为空队列，则返回1；否则返回-1Q_Data Q_Empty(SqQueue Q) &#123; if (Q.front == Q.rear) // 队列空的标志 return 1; else return -1;&#125;// 返回Q的元素个数，即队列的长度Q_Data Q_Length(SqQueue Q) &#123; return (Q.rear - Q.front + MAX_QSIZE) % MAX_QSIZE;&#125;// 若队列不空，则用e返回Q的队头元素，并返回OK；否则返回ERRORQ_Data Q_GetHead(SqQueue Q, Q_Data &amp;e) &#123; if (Q.front == Q.rear) // 队列空 return -1; e = Q.data[Q.front]; return 1;&#125;// 打印队列中的内容void Q_Print(SqQueue Q) &#123; Q_Data p = Q.front % MAX_QSIZE; while (Q.rear != p) &#123; cout &lt;&lt; Q.data[p] &lt;&lt; endl; p = (p + 1) % MAX_QSIZE; &#125;&#125;// 插入元素e为Q的新的队尾元素Q_Data Q_Put(SqQueue *Q, Q_Data e) &#123; if ((Q-&gt;rear + 1) % MAX_QSIZE == Q-&gt;front) // 队列满 return -1; Q-&gt;data[Q-&gt;rear] = e; Q-&gt;rear = (Q-&gt;rear + 1) % MAX_QSIZE; return 1;&#125;// 若队列不空，则删除Q的队头元素，用e返回其值，并返回1；否则返回-1Q_Data Q_Poll(SqQueue *Q, Q_Data &amp;e) &#123; if (Q-&gt;front == Q-&gt;rear) // 队列空 return -1; e = Q-&gt;data[Q-&gt;front]; Q-&gt;front = (Q-&gt;front + 1) % MAX_QSIZE; return 1;&#125; 单链队列 单链队列使用链表作为基本数据结构，所以不存在”假溢出”的问题，队列长度也没有限制。但插入和读取的时间代价较高，虽然使用链表实现，但链表的优势（O(1)任意节点插入）在队列中被抹去了，因为链表不允许操纵除头尾节点以外的节点，每次插入都需右移指针。下面是一个单链队列的实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// 队列的数据类型typedef int Q_Data;// 定义单链队列的存储结构typedef struct QNode &#123; Q_Data data; QNode *next;&#125;QNode,*QNodePtr;typedef struct LinkQueue&#123; //队头 队尾 指针 QNodePtr front,rear;&#125;LinkQueue;// 构造一个空队列QLinkQueue* Q_Init() &#123; //申请内存 LinkQueue* Q = (LinkQueue*)malloc(sizeof(LinkQueue)); //如果 Q 为 NULL 说明 内存申请失败，结束程序 if (!Q) exit(OVERFLOW); //初始化头尾节点 指向相同地址 Q-&gt;front = Q-&gt;rear = (QNodePtr)malloc(sizeof(QNode)); //如果 Q-&gt;front 为 NULL 说明 内存申请失败，结束程序 if (!Q-&gt;front) exit(OVERFLOW); Q-&gt;front-&gt;next = NULL; return Q;&#125;// 销毁队列Q(无论空否均可)void Q_Destroy(LinkQueue *Q) &#123; while (Q-&gt;front) &#123; //将队尾指向队头下一个节点的地址（第1个节点） Q-&gt;rear = Q-&gt;front-&gt;next; //回收队头 free(Q-&gt;front); //将队头指向队尾（相当于第1个节点变成了队头，然后依次第2个第3个、、、 //直到没有下一个节点，也就是 Q-&gt;front == NULL 的时候） Q-&gt;front = Q-&gt;rear; &#125; free(Q);&#125;// 将Q清为空队列void Q_Clear(LinkQueue *Q) &#123; QNodePtr p, q; //将队尾指向队头点的地址 Q-&gt;rear = Q-&gt;front; //取出第1个节点 p = Q-&gt;front-&gt;next; //回收第1个节点 Q-&gt;front-&gt;next = NULL; while (p) &#123; //将 q 指向 p（第1个节点） q = p; //将 p 指向 第2个节点 p = p-&gt;next; //回收第2个节点 free(q); &#125;&#125;// 若Q为空队列，则返回-1，否则返回1Q_Data Q_Empty(LinkQueue Q) &#123; if (Q.front-&gt;next == NULL) return 1; else return -1;&#125;// 求队列的长度Q_Data Q_Length(LinkQueue Q) &#123; Q_Data i = 0; QNodePtr p; p = Q.front; //遍历队列中的节点，直到队尾等于队头 while (Q.rear != p) &#123; i++; p = p-&gt;next; &#125; return i;&#125;// 打印队列中的内容void Q_Print(LinkQueue Q) &#123; Q_Data i = 0; QNodePtr p; p = Q.front; while (Q.rear != p) &#123; i++; cout &lt;&lt; p-&gt;next-&gt;data &lt;&lt; endl; p = p-&gt;next; &#125;&#125;// 若队列不空，则用e返回Q的队头元素，并返回1，否则返回-1Q_Data Q_GetHead(LinkQueue Q, Q_Data &amp;e) &#123; QNodePtr p; if (Q.front == Q.rear) return -1; p = Q.front-&gt;next; e = p-&gt;data; return 1;&#125;// 插入元素e为Q的新的队尾元素void Q_Put(LinkQueue *Q, Q_Data e) &#123; QNodePtr p = (QNodePtr)malloc(sizeof(QNode)); if (!p) // 存储分配失败 exit(OVERFLOW); p-&gt;data = e; p-&gt;next = NULL; //FIFO，将新节点追加到尾节点后面 Q-&gt;rear-&gt;next = p; //将新的节点变成尾节点 Q-&gt;rear = p;&#125;// 若队列不空，删除Q的队头元素，用e返回其值，并返回1，否则返回-1Q_Data Q_Poll(LinkQueue *Q,Q_Data &amp;e) &#123; QNodePtr p; if (Q-&gt;front == Q-&gt;rear) return -1; //取出头节点 p = Q-&gt;front-&gt;next; //取出头节点的数据 e = p-&gt;data; cout &lt;&lt; e &lt;&lt; endl; Q-&gt;front-&gt;next = p-&gt;next; if (Q-&gt;rear == p) Q-&gt;rear = Q-&gt;front; free(p); cout &lt;&lt; e &lt;&lt; endl; return 1;&#125; 什么是假溢出 假溢出就是系统作为队列用的存储区还没有满,但队列却发生了溢出,我们把这种现象称为”假溢出”。假设我们有一个非循环队列Q，队头指针为Q-&gt;front,队尾指针为Q-&gt;rear,长度为m，队列中元素在向量中的下标从0到m-1。入队Q-&gt;rear++，出队Q-&gt;front++，现在入队m个元素到队列中，此时Q-&gt;front == 0，Q-&gt;rear == m，现在出队m个元素，此时 Q-&gt;front == Q-&gt;rear == m，现在队列中已经没有元素，但此时再做入队操作时，就发生了”假溢出”。下面举个例子123456789101112131415161718192021222324cout &lt;&lt; "初始化非循环队列" &lt;&lt; endl;Queue *Q = Q_Init();//此时 Q-&gt;front == 0,Q-&gt;rear == 0;cout &lt;&lt; "插入数据（put）" &lt;&lt; endl;Q_Put(Q, 111);Q_Put(Q, 222);Q_Put(Q, 333);Q_Put(Q, 444);Q_Put(Q, 555);//此时 Q-&gt;front == 0,Q-&gt;rear == 5;cout &lt;&lt; "取出并删除元素（poll）" &lt;&lt; endl;Q_Data head_data;Q_Poll(Q,head_data);Q_Poll(Q,head_data);Q_Poll(Q,head_data);Q_Poll(Q,head_data);Q_Poll(Q,head_data);//此时 Q-&gt;front == 5,Q-&gt;rear == 5;队列中没有数据cout &lt;&lt; "插入数据（put）" &lt;&lt; endl;Q_Put(Q, 666);//此时 Q-&gt;front == 5,Q-&gt;rear == 5; 没有变化，Q_Put() 会返回 -1，也就是插入失败，这就发生了 "假溢出" 怎么解决假溢出 将队列看成首尾相连即循环队列 1234567891011121314151617181920212223242526272829303132333435// 循环队列中有两种方法可以判断队空或队满// 1.“牺牲一个单元”，Q-&gt;front == Q-&gt;rear 时为队空，(Q-&gt;rear + 1) % MAX_QSIZE == Q-&gt;front 时为队满。// 2.“设标记”，如设标记tag，若出队时发生Q-&gt;front==Q-&gt;rear为队空，tag == 1；若入队时发生Q-&gt;front == Q-&gt;rear为队满，tag == 2。// 一般来说都是使用第1种方法，下面解析一下第一种方法。cout &lt;&lt; "初始化循环队列" &lt;&lt; endl;SqQueue *Q = Q_Init();//此时 Q-&gt;front == 0,Q-&gt;rear == 0;cout &lt;&lt; "插入数据（put）" &lt;&lt; endl;//入队时 Q-&gt;rear = (Q-&gt;rear + 1) % MAX_QSIZEQ_Data front_data;Q_Put(Q,111);Q_Put(Q,222);Q_Put(Q,333);Q_Put(Q,444);Q_Put(Q,555);//此时 Q-&gt;front == 0,Q-&gt;rear == 5;cout &lt;&lt; "取出并删除元素（poll）" &lt;&lt; endl;//出队时 Q-&gt;front = (Q-&gt;front + 1) % MAX_QSIZEQ_Data head_data;Q_Poll(Q,head_data);Q_Poll(Q,head_data);Q_Poll(Q,head_data);Q_Poll(Q,head_data);Q_Poll(Q,head_data);//此时 Q-&gt;front == 5,Q-&gt;rear == 5;队列中没有数据cout &lt;&lt; "插入数据（put）" &lt;&lt; endl;//入队时 Q-&gt;rear = (Q-&gt;rear + 1) % MAX_QSIZEQ_Put(Q,666);Q_Put(Q,777);Q_Put(Q,888);//此时 Q-&gt;front == 5,Q-&gt;rear == 2;队列三个元素 出队时将队列所有元素向前“平移”1位 12345678910111213141516171819202122232425262728293031323334353637383940414243cout &lt;&lt; "初始化非循环队列" &lt;&lt; endl;Queue *Q = Q_Init();//此时 Q-&gt;front == 0,Q-&gt;rear == 0;cout &lt;&lt; "插入数据（put）" &lt;&lt; endl;Q_Put(Q, 111);Q_Put(Q, 222);Q_Put(Q, 333);Q_Put(Q, 444);Q_Put(Q, 555);//此时 Q-&gt;front == 0,Q-&gt;rear == 5;//将非循环队列出列方法更改为如下// 出列 解决"假溢出"Q_Data Q_Poll_New(Queue *Q,Q_Data &amp;e) &#123; //如果当前元素数量等于最大数量 返回 -1 if (Q-&gt;front == 0 || Q-&gt;front == MAX_QSIZE) return -1; e = Q-&gt;Array[Q-&gt;front]; int x = MAX_QSIZE; while(x != 0)&#123; Q-&gt;Array[x-1] = Q-&gt;Array[x]; x--; &#125; Q-&gt;rear--; // 移出后減少1 Q-&gt;length--; return 1;&#125;cout &lt;&lt; "取出并删除元素（poll）" &lt;&lt; endl;//调用新出列方法Q_Data head_data;Q_Poll_New(Q,head_data);Q_Poll_New(Q,head_data);Q_Poll_New(Q,head_data);Q_Poll_New(Q,head_data);Q_Poll_New(Q,head_data);//此时 Q-&gt;front == 0,Q-&gt;rear == 0;队列中没有数据cout &lt;&lt; "插入数据（put）" &lt;&lt; endl;Q_Put(Q, 666);//此时 Q-&gt;front == 0,Q-&gt;rear == 1;队列中1个元素 总结 非循环队列是最简单的队列，动态数组/数组实现，队列大小是固定，插入（入队）和查找（出队）快，可能会出现”假溢出”的情况。 动态数组/数组实现，队列大小是固定，插入（入队）和查找（出队）快，不会出现”假溢出”。 单链队列使用链表实现，不存在”假溢出”的问题，队列长度没有限制，插入和读取的时间代价较高。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之向量]]></title>
    <url>%2FdataStructure%2FdataStructure-vector%2F</url>
    <content type="text"><![CDATA[什么是向量(vector)向量（vector）是一个抽象数据结构，为一组数据模型，定义一组操作，不涉及具体的储存方式，可以用不同的数据类型来实现，多数使用数组来实现，所以也可以认为，向量是数组的抽象与泛化。向量（Vector）和列表（List）都属于序列，所谓序列就是以某种规律依次排列的一组对象，是数据结构设计的基础。 点击这里查看博客对应的完整代码 基于数组的简单实现下面是一个简单的向量接口，包含一些常用的操作。123456789101112131415161718192021222324public interface VectorTemp&lt;E&gt; &#123; int size(); boolean isEmpty(); boolean contains(E e); int indexOf(E e, int index); int lastIndexOf(E e); int lastIndexOf(E e, int index); E get(int index) throws VectorViolationException; E set(int index, E e) throws VectorViolationException; boolean add(E e); E insert(int index, E obj); E remove(int index) throws VectorViolationException;&#125; 下面是上面我们定义的操作实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165public class MyVector&lt;E&gt; implements VectorTemp&lt;E&gt; &#123; private int capacityIncrement; private int elementCount; private Object[] elementData; public MyVector(int initialCapacity) &#123; if (initialCapacity &lt; 0)&#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; this.elementData = new Object[initialCapacity]; this.capacityIncrement = initialCapacity; &#125; public MyVector()&#123; this(10); &#125; public MyVector(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class)&#123; elementData = Arrays.copyOf(elementData, elementCount, Object[].class); &#125; &#125; @Override public synchronized int size() &#123; return elementCount; &#125; @Override public synchronized boolean isEmpty() &#123; return elementCount == 0; &#125; @Override public boolean contains(E e) &#123; return indexOf(e, 0) &gt;= 0; &#125; @Override public synchronized int indexOf(Object o, int index) &#123; if (o == null) &#123; for (int i = index ; i &lt; elementCount ; i++)&#123; if (elementData[i]==null) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = index ; i &lt; elementCount ; i++) &#123; if (o.equals(elementData[i])) &#123; return i; &#125; &#125; &#125; return -1; &#125; @Override public synchronized int lastIndexOf(Object o) &#123; return lastIndexOf(o, elementCount-1); &#125; @Override public synchronized int lastIndexOf(Object o, int index) &#123; if (index &gt;= elementCount) &#123; throw new IndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; if (o == null) &#123; for (int i = index; i &gt;= 0; i--) &#123; if (elementData[i] == null)&#123; return i; &#125; &#125; &#125; else &#123; for (int i = index; i &gt;= 0; i--) &#123; if (o.equals(elementData[i])) &#123; return i; &#125; &#125; &#125; return -1; &#125; @Override public synchronized E get(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; return elementData(index); &#125; @Override public synchronized E set(int index, Object element) throws VectorViolationException &#123; rankValid(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; @Override public synchronized boolean add(Object e) &#123; if(elementCount + 1 &gt;= capacityIncrement)&#123; capacity(); &#125; elementData[elementCount] = e; elementCount++; return true; &#125; @Override public synchronized E insert(int index, E obj) &#123; if(index &lt; 0 || index &gt; elementCount)&#123; throw new VectorViolationException("rankOutOfBound"); &#125; if(elementCount + 1 &gt;= capacityIncrement)&#123; capacity(); &#125; for (int i = elementCount; i &gt; index; i--) &#123; elementData[i] = elementData[i - 1]; &#125; elementData[index] = obj; elementCount++; return obj; &#125; private E elementData(int index) &#123; return (E) elementData[index]; &#125; @Override public synchronized E remove(int index) throws VectorViolationException &#123; rankValid(index); E bak = elementData(index); for (int i = index; i &lt; elementCount - 1; i++)&#123; elementData[i] = elementData[i + 1]; &#125; elementCount--; return bak; &#125; public synchronized void capacity() &#123; capacityIncrement *= 2; Object[] arrObj = new Object[capacityIncrement]; System.arraycopy(elementData, 0, arrObj, 0, elementCount); elementData = arrObj; &#125; private void rankValid(int index)&#123; if(index &lt; 0 || index &gt;= capacityIncrement)&#123; throw new VectorViolationException("rankOutOfBound"); &#125; &#125;&#125; 下面是测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152VectorTemp&lt;String&gt; myVector = new MyVector&lt;String&gt;(2);System.out.println("是否为空：" + myVector.isEmpty());System.out.println("增加元素,当前大小：" + myVector.size());myVector.add("A");myVector.add("B");myVector.add("C");for (int i = 0; i &lt; myVector.size(); i++)&#123; System.out.println(myVector.get(i));&#125;System.out.println("是否为空：" + myVector.isEmpty());System.out.println("插入元素,当前大小：" + myVector.size());myVector.insert(2,"I");for (int i = 0; i &lt; myVector.size(); i++)&#123; System.out.println(myVector.get(i));&#125;System.out.println("删除元素,当前大小：" + myVector.size());myVector.remove(3);for (int i = 0; i &lt; myVector.size(); i++)&#123; System.out.println(myVector.get(i));&#125;System.out.println("是否存在元素R：" + myVector.contains("R"));System.out.println("替换元素,当前大小：" + myVector.size());myVector.set(1,"R");System.out.println("是否存在元素R：" + myVector.contains("R"));for (int i = 0; i &lt; myVector.size(); i++)&#123; System.out.println(myVector.get(i));&#125;//执行结果是否为空：true增加元素,当前大小：0ABC是否为空：false插入元素,当前大小：3ABIC删除元素,当前大小：4ABI是否存在元素R：false替换元素,当前大小：3是否存在元素R：trueARI 到这里，一个完整的向量实现就结束了，感兴趣的可以看看java中的向量（java.util.Vector）源码。 总结 向量是一个抽象数据结构，为一组数据模型，定义一组操作，不涉及具体的储存方式，可以用不同的数据类型来实现。 向量属于序列的一种，以某种规律依次排列的一组对象。 向量是是数据结构设计的基础。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>向量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之链表]]></title>
    <url>%2FdataStructure%2FdataStructure-chainTable%2F</url>
    <content type="text"><![CDATA[什么是链表链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（”links”）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表等。 点击这里查看博客对应的完整代码 单向链表链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。链表最基本的结构是在每个节点保存数据和到下一个节点的地址，在最后一个节点保存一个特殊的结束标记，另外在一个固定的位置保存指向第一个节点的指针，有的时候也会同时储存指向最后一个节点的指针。一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。但是也可以提前把一个节点的位置另外保存起来，然后直接访问。当然如果只是访问数据就没必要了，不如在链表上储存指向实际数据的指针。这样一般是为了访问链表中的下一个或者前一个节点（需要储存反向的指针，也就是双向链表）。相对于下面说的双向链表，这种普通的，每个节点只有一个指针的链表也叫单向链表，或者单链表，通常用在每次都只会按顺序遍历这个链表的时候。 单向链表的实现定义单向链表数据结构12345struct node&#123; int data; ss* next;&#125;; 这是一个最简单的单向链表的数据结构，链表中的每个元素我们称之为node，node中的data为数据域，next为指针域，指向下一个元素，下面我们来声明几个链表，并给链表的数据域中放上数据。 123456node* s1 = new node();s1-&gt;data = 1;node* s2 = new node();s2-&gt;data = 2;node* s3 = new node();s3-&gt;data = 3; 这里我们初始化了3个node，将node关联起来后才是一个完整的链表，那么怎么关联呢？我们继续看下面的代码。1234567891011s1-&gt;next = s2;s2-&gt;next = s3;//打印链表中的数据cout &lt;&lt; s1-&gt;data &lt;&lt; endl;cout &lt;&lt; s1-&gt;next-&gt;data &lt;&lt; endl;cout &lt;&lt; s1-&gt;next-&gt;next-&gt;data &lt;&lt; endl;//输出结果为//1//2//3 没错，到这里我们已经实现了一个完整的链表了，是不是很简单。下面我们先插入一个节点，并输出一下每个node的内存地址和每个node中的数据。123456789101112131415161718192021222324252627282930// 插入节点// 链表的插入非常简单，复杂度仅为O(1)。// 这也就是为什么说链表插入快，因为他只需要改变插入元素前后的指针指向。node* s4 = new node();s4-&gt;data = 40;s1-&gt;next = s4;s4-&gt;next = s2;// 打印内存地址cout &lt;&lt; s1 &lt;&lt; endl;cout &lt;&lt; s2 &lt;&lt; endl;cout &lt;&lt; s3 &lt;&lt; endl;//输出的内存地址(以下地址仅供参考，每个计算机输出的内存地址都不一样)//以下内存地址毫无规律，如果有，纯属巧合~//0xff1478//0xff14a8//0xff14b8// 链表的查询复杂度为O(n)，除非查询的是首元素。// 由于链表内存不连续，所以没有下标的概念，取值只能循环取，// 这也就是为什么链表查询慢的原因// 因为我们例子中的链表很短，并且为了更加直观，所以我们这里没有用循环。cout &lt;&lt; s1-&gt;data &lt;&lt; endl;cout &lt;&lt; s1-&gt;next-&gt;data &lt;&lt; endl;cout &lt;&lt; s1-&gt;next-&gt;next-&gt;data &lt;&lt; endl;//输出结果为//1//40//2//3 从上面的代码中很明显的体现出了链表的特点，线性、无序(这里说的无序是内存无序，和数据顺序无关)、查询慢、插入快。 双向链表一种更复杂的链表是“双向链表”或“双面链表”。双向链表中不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样可以从任何一个节点访问前一个节点，当然也可以访问后一个节点，以至整个链表。一般是在需要大批量存储另外储存数据在链表中的位置的时候用。双向链表也可以配合下面的其他链表的扩展使用。由于另外储存了指向链表内容的指针，并且可能会修改相邻的节点，有的时候第一个节点可能会被删除或者在之前添加一个新的节点，这时候就要修改指向首个节点的指针。有一种方便的可以消除这种特殊情况的方法是在最后一个节点之后、第一个节点之前储存一个永远不会被删除或者移动的虚拟节点（头节点），形成一个下面说的循环链表。这个虚拟节点之后的节点就是真正的第一个节点。 循环链表将一个单向链表或双向链表首尾相连，就成了循环链表。这种方式在单向和双向链表中皆可实现，区别仅在于单向循环链表只能从一个方向循环，双向循环链表可以超两个方向循环。循环链表可以被视为“无头无尾”，循环链表中第一个节点之前就是最后一个节点，反之亦然。循环链表的无边界使得在这样的链表上设计算法会比普通链表更加容易。对于新加入的节点应该是在第一个节点之前还是最后一个节点之后可以根据实际要求灵活处理，区别不大(详见下面实例代码)。 双向循环链表的实现有了上面的了解，我们下面来实现一个完整的双向循环链表。首先我们定义头文件，头文件大家可以理解为java语言中的接口，如果我们不定义头文件也是可以的，只不过定义了头文件，我们实现了什么功能，大家在头文件中可以一目了然。1234567891011121314151617181920212223242526272829303132#ifndef LINKED_LIST_H#define LINKED_LIST_H//打印typedef void node_print_fun_t(void*);//比较typedef int node_compare_fun_t(const void*, const void*);typedef void LINKED_LIST_T;//初始化LINKED_LIST_T *linked_list_new(int elmsize);//销毁int linked_list_delete(int *ptr);//插入节点 尾插入int linked_list_node_append(int *ptr, const void *data);//插入节点 头插入int linked_list_node_prepend(int *ptr, const void *data);//遍历节点int linked_list_travel(int *ptr, node_print_fun_t *proc);//删除节点void linked_list_node_delete(int *ptr, node_compare_fun_t *compare, const void *key);//查找节点void *linked_list_node_find(int *ptr, node_compare_fun_t *compare, const void *key);#endif 定义链表的数据结构1234567891011//定义双向链表节点struct node&#123; void *data; node *prev,*next;&#125;;//定义双向链表结构体struct linked_list&#123; node head; //元素大小 int elm_size;&#125;; 看，是不是和我们之前实现的单向链表差不多呢。然后我们实现头文件中的方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//初始化LINKED_LIST_T *linked_list_new(int elm_size) &#123; linked_list *new_list = (linked_list *)malloc(sizeof(linked_list)); if (new_list == NULL) return NULL; new_list-&gt;head.data = NULL; new_list-&gt;head.next = &amp;new_list-&gt;head; new_list-&gt;head.prev = &amp;new_list-&gt;head; new_list-&gt;elm_size = elm_size; return (void *)new_list;&#125;;//销毁int linked_list_delete(LINKED_LIST_T *ptr) &#123; linked_list *me = (linked_list*)ptr; node *curr, *save; for (curr = me-&gt;head.next; curr != &amp;me-&gt;head; curr = save) &#123; save = curr-&gt;next; free(curr-&gt;data); free(curr); &#125; free(me); return 0;&#125;//插入节点 在元素末尾追加元素int linked_list_node_append(LINKED_LIST_T *ptr, const void *data) &#123; linked_list *new_list = (linked_list*)ptr; node *new_node; new_node = (node*)malloc(sizeof(node)); if (new_node == NULL) return -1; new_node-&gt;data = malloc(new_list-&gt;elm_size); if (new_node-&gt;data == NULL) &#123; free(new_node); return -1; &#125; //复制内存 memcpy(new_node-&gt;data, data, new_list-&gt;elm_size); new_list-&gt;head.prev-&gt;next = new_node; new_node-&gt;prev = new_list-&gt;head.prev; new_list-&gt;head.prev = new_node; new_node-&gt;next = &amp;new_list-&gt;head; return 0;&#125;//插入节点 在元素头追加元素int linked_list_node_prepend(LINKED_LIST_T *ptr, const void *data) &#123; linked_list *new_list = (linked_list*)ptr; node *new_node; new_node = (node*)malloc(sizeof(node)); if (new_node == NULL) return -1; new_node-&gt;data = malloc(new_list-&gt;elm_size); if (new_node-&gt;data == NULL) &#123; free(new_node); return -1; &#125; //复制内存 memcpy(new_node-&gt;data, data, new_list-&gt;elm_size); new_list-&gt;head.next-&gt;prev = new_node; new_node-&gt;next = new_list-&gt;head.next; new_list-&gt;head.next = new_node; new_node-&gt;prev = &amp;new_list-&gt;head; return 0;&#125;//遍历节点int linked_list_travel(LINKED_LIST_T *ptr, node_print_fun_t *proc) &#123; linked_list *me = (linked_list*)ptr; node *curr; for (curr = me-&gt;head.next; curr != &amp;me-&gt;head; curr = curr-&gt;next)&#123; proc(curr-&gt;data); // proc(something you like) &#125; return 0;&#125;//删除节点void linked_list_node_delete(LINKED_LIST_T *ptr, node_compare_fun_t *comp, const void *key) &#123; linked_list *me = (linked_list*)ptr; node *curr; for (curr = me-&gt;head.next; curr != &amp;me-&gt;head; curr = curr-&gt;next) &#123; if ( (*comp)(curr-&gt;data, key) == 0 ) &#123; node *_next, *_prev; _prev = curr-&gt;prev; _next = curr-&gt;next; _prev-&gt;next = _next; _next-&gt;prev = _prev; free(curr-&gt;data); free(curr); break; &#125; &#125; return;&#125;//查找节点void *linked_list_node_find(LINKED_LIST_T *ptr, node_compare_fun_t *comp, const void *key) &#123; linked_list *me = (linked_list*)ptr; node *curr; for (curr = me-&gt;head.next; curr != &amp;me-&gt;head; curr = curr-&gt;next) &#123; if ( (*comp)(curr-&gt;data, key) == 0 ) return curr-&gt;data; &#125; return NULL;&#125;//比较函数int compare(const void *data1, const void *data2)&#123; if (*((int*)data1) == *((int*)data2))&#123; return 0; &#125; return -1;&#125;//打印函数void proc(void *data)&#123; cout &lt;&lt; *((int*)data) &lt;&lt; endl;&#125; 链表的存储结构链表中的节点不需要以特定的方式存储，但是集中存储也是可以的，主要分下面这几种具体的存储方法： 共用存储空间链表的节点和其它的数据共用存储空间，优点是可以存储无限多的内容（不过要处理器支持这个大小，并且存储空间足够的情况下），不需要提前分配内存；缺点是由于内容分散，有时候可能不方便调试。 独立存储空间一个链表或者多个链表使用独立的存储空间，一般用数组或者类似结构实现，优点是可以自动获得一个附加数据：唯一的编号，并且方便调试；缺点是不能动态的分配内存。当然，另外的在上面加一层块状链表用来分配内存也是可以的，这样就解决了这个问题。这种方法有时候被叫做数组模拟链表，但是事实上只是用表示在数组中的位置的下标索引代替了指向内存地址的指针，这种下标索引其实也是逻辑上的指针，整个结构还是链表，并不算是被模拟的（但是可以说成是用数组实现的链表）。 总结单向链表链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。 双向链表双向链表中不仅有指向后一个节点的指针，还有指向前一个节点的指针。 循环链表将一个单向链表或双向链表首尾相连，就成了循环链表。这种方式在单向和双向链表中皆可实现，区别仅在于单向循环链表只能从一个方向循环，双向循环链表可以超两个方向循环。 链表特点线性、无序、查询慢、插入快]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之数组]]></title>
    <url>%2FdataStructure%2FdataStructure-array%2F</url>
    <content type="text"><![CDATA[什么是数组数组（array），是有序的元素序列。若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素（element），有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按无序的形式组织起来的一种形式。数组，是由相同类型的元素的集合所组成的数据结构，分配一块连续的内存来存储。利用元素的索引（index）可以计算出该元素对应的存储地址。数组是最早期和最重要的数据结构之一，很多程序都会用到数组。它们也用于实现许多其他数据结构，譬如列表（list）和字符串（string）。 点击这里查看博客对应的完整代码 一维数组一维数组是计算机程序中最基本最简单的数据结构类型，由数字组成的以单纯的排序结构排列的结构单一的数组。 一维数组常规操作静态一维数组123456789101112cout &lt;&lt; "静态创建一维数组" &lt;&lt; endl;int a[3] = &#123;1,2,3&#125;;cout &lt;&lt; "查询" &lt;&lt; endl;cout &lt;&lt; a[0] &lt;&lt; endl;cout &lt;&lt; a[1] &lt;&lt; endl;cout &lt;&lt; a[2] &lt;&lt; endl;cout &lt;&lt; "修改" &lt;&lt; endl;a[0] = 4;cout &lt;&lt; "查询" &lt;&lt; endl;cout &lt;&lt; a[0] &lt;&lt; endl;cout &lt;&lt; a[1] &lt;&lt; endl;cout &lt;&lt; a[2] &lt;&lt; endl; 动态一维数组1234567891011121314151617cout &lt;&lt; "动态创建一维数组" &lt;&lt; endl;int length = 3;int *a1 = (int *)malloc(length * sizeof(int));cout &lt;&lt; "初始化" &lt;&lt; endl;a1[0] = 1;a1[1] = 2;a1[2] = 3;cout &lt;&lt; "查询" &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; 0 &lt;&lt; "值=" &lt;&lt; a1[0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; 1 &lt;&lt; "值=" &lt;&lt; a1[1] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; 2 &lt;&lt; "值=" &lt;&lt; a1[2] &lt;&lt; endl;cout &lt;&lt; "修改" &lt;&lt; endl;*(a1+1) = 4;cout &lt;&lt; "查询" &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; 0 &lt;&lt; "值=" &lt;&lt; a1[0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; 1 &lt;&lt; "值=" &lt;&lt; a1[1] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; 2 &lt;&lt; "值=" &lt;&lt; a1[2] &lt;&lt; endl; 二维数组二维数组本质上是以数组作为数组元素的数组，即“数组的数组”。 二维数组的常规操作静态二维数组123456789101112131415161718cout &lt;&lt; "静态创建二维数组" &lt;&lt; endl;int b[2][2] =&#123; &#123;11,22&#125;, &#123;33,44&#125;&#125;;cout &lt;&lt; "查询" &lt;&lt; endl;cout &lt;&lt; b[0][0] &lt;&lt; endl;cout &lt;&lt; b[0][1] &lt;&lt; endl;cout &lt;&lt; b[1][0] &lt;&lt; endl;cout &lt;&lt; b[1][1] &lt;&lt; endl;cout &lt;&lt; "修改" &lt;&lt; endl;b[0][1] = 55;cout &lt;&lt; "查询" &lt;&lt; endl;cout &lt;&lt; b[0][0] &lt;&lt; endl;cout &lt;&lt; b[0][1] &lt;&lt; endl;cout &lt;&lt; b[1][0] &lt;&lt; endl;cout &lt;&lt; b[1][1] &lt;&lt; endl; 动态二维数组12345678910111213141516171819202122232425cout &lt;&lt; "动态创建二维数组" &lt;&lt; endl;//一维长度/行长度int x = 2;//二维长度/列长度int y = 2;//数组总长度int length1 = x * y;int *b1 = (int *)malloc(length1 * sizeof(int));cout &lt;&lt; "初始化" &lt;&lt; endl;b1[0 * y + 0] = 11;b1[0 * y + 1] = 22;;b1[1 * y + 0] = 33;;b1[1 * y + 1] = 44;;cout &lt;&lt; "查询" &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; "值=" &lt;&lt; b1[0 * y + 0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; "值=" &lt;&lt; b1[0 * y + 1] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; "值=" &lt;&lt; b1[1 * y + 0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; "值=" &lt;&lt; b1[1 * y + 1] &lt;&lt; endl;cout &lt;&lt; "修改" &lt;&lt; endl;b1[0*2+0] = 55;cout &lt;&lt; "查询" &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; "值=" &lt;&lt; b1[0 * y + 0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; "值=" &lt;&lt; b1[0 * y + 1] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; "值=" &lt;&lt; b1[1 * y + 0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; "值=" &lt;&lt; b1[1 * y + 1] &lt;&lt; endl; 多维数组三维及其以上的数组称为多维数组，三维数组具有高、宽、深的概念，或者说行、列、层的概念，由于其可以用来描述三维空间中的位置或状态而被广泛使用。 多维数组的常规操作静态多维数组1234567891011121314151617181920212223242526272829303132cout &lt;&lt; "静态创建多维数组" &lt;&lt; endl;int c[2][2][2] =&#123; &#123; &#123;111,222&#125;, &#123;333,444&#125; &#125;, &#123; &#123;555,666&#125;, &#123;777,888&#125; &#125;&#125;;cout &lt;&lt; "查询" &lt;&lt; endl;cout &lt;&lt; c[0][0][0] &lt;&lt; endl;cout &lt;&lt; c[0][0][1] &lt;&lt; endl;cout &lt;&lt; c[0][1][0] &lt;&lt; endl;cout &lt;&lt; c[0][1][1] &lt;&lt; endl;cout &lt;&lt; c[1][0][0] &lt;&lt; endl;cout &lt;&lt; c[1][0][1] &lt;&lt; endl;cout &lt;&lt; c[1][1][0] &lt;&lt; endl;cout &lt;&lt; c[1][1][1] &lt;&lt; endl;cout &lt;&lt; "修改" &lt;&lt; endl;c[1][0][0] = 666;cout &lt;&lt; "查询" &lt;&lt; endl;cout &lt;&lt; c[0][0][0] &lt;&lt; endl;cout &lt;&lt; c[0][0][1] &lt;&lt; endl;cout &lt;&lt; c[0][1][0] &lt;&lt; endl;cout &lt;&lt; c[0][1][1] &lt;&lt; endl;cout &lt;&lt; c[1][0][0] &lt;&lt; endl;cout &lt;&lt; c[1][0][1] &lt;&lt; endl;cout &lt;&lt; c[1][1][0] &lt;&lt; endl;cout &lt;&lt; c[1][1][1] &lt;&lt; endl; 动态多维数组123456789101112131415161718192021222324252627282930313233343536373839cout &lt;&lt; "动态创建多维数组" &lt;&lt; endl;//一维长度/高度int h = 2;//二维长度/宽度int w = 2;//三维长度/深度int d = 2;//数组总长度int length2 = h * w * d;int *c1 = (int *)malloc(length2 * sizeof(int));cout &lt;&lt; "初始化" &lt;&lt; endl;c1[0 * h * w + 0 * d + 0] = 111;c1[0 * h * w + 0 * d + 1] = 222;c1[0 * h * w + 1 * d + 0] = 333;c1[0 * h * w + 1 * d + 1] = 444;c1[1 * h * w + 0 * d + 0] = 555;c1[1 * h * w + 0 * d + 1] = 666;c1[1 * h * w + 1 * d + 0] = 777;c1[1 * h * w + 1 * d + 1] = 888;cout &lt;&lt; "查询" &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (0 * h * w + 0 * d + 0) &lt;&lt; "值=" &lt;&lt; c1[0 * h * w + 0 * d + 0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (0 * h * w + 0 * d + 1) &lt;&lt; "值=" &lt;&lt; c1[0 * h * w + 0 * d + 1] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (0 * h * w + 1 * d + 0) &lt;&lt; "值=" &lt;&lt; c1[0 * h * w + 1 * d + 0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (0 * h * w + 1 * d + 1) &lt;&lt; "值=" &lt;&lt; c1[0 * h * w + 1 * d + 1] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (1 * h * w + 0 * d + 0) &lt;&lt; "值=" &lt;&lt; c1[1 * h * w + 0 * d + 0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (1 * h * w + 0 * d + 1) &lt;&lt; "值=" &lt;&lt; c1[1 * h * w + 0 * d + 1] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (1 * h * w + 1 * d + 0) &lt;&lt; "值=" &lt;&lt; c1[1 * h * w + 1 * d + 0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (1 * h * w + 1 * d + 1) &lt;&lt; "值=" &lt;&lt; c1[1 * h * w + 1 * d + 1] &lt;&lt; endl;cout &lt;&lt; "修改" &lt;&lt; endl;c1[0 * w * d + 0 * d + 0] = 666;cout &lt;&lt; "查询" &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (0 * h * w + 0 * d + 0) &lt;&lt; "值=" &lt;&lt; c1[0 * h * w + 0 * d + 0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (0 * h * w + 0 * d + 1) &lt;&lt; "值=" &lt;&lt; c1[0 * h * w + 0 * d + 1] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (0 * h * w + 1 * d + 0) &lt;&lt; "值=" &lt;&lt; c1[0 * h * w + 1 * d + 0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (0 * h * w + 1 * d + 1) &lt;&lt; "值=" &lt;&lt; c1[0 * h * w + 1 * d + 1] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (1 * h * w + 0 * d + 0) &lt;&lt; "值=" &lt;&lt; c1[1 * h * w + 0 * d + 0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (1 * h * w + 0 * d + 1) &lt;&lt; "值=" &lt;&lt; c1[1 * h * w + 0 * d + 1] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (1 * h * w + 1 * d + 0) &lt;&lt; "值=" &lt;&lt; c1[1 * h * w + 1 * d + 0] &lt;&lt; endl;cout &lt;&lt; "下标=" &lt;&lt; (1 * h * w + 1 * d + 1) &lt;&lt; "值=" &lt;&lt; c1[1 * h * w + 1 * d + 1] &lt;&lt; endl; 元素标识符和定址公式首先我们先明确几个概念 数组名 = 数组首元素地址 = 元素基址 元素地址 = 元素基址 + 元素下标 元素基址 + 元素下标 的值 会被解析成 定址公式 元素标识符和定址公式体现出了数组的内存连续性 下面所有代码全部使用”下标优先”规则，并且内存连续，实际实现 二维 多维数组和本例子可能有所不同，比如可能维度之间内存不连续等，以下例子只为表达概念。12345678910111213141516171819202122232425//验证一维数组 定址公式 = (a1+0) + i * sizeof(DataType)cout &lt;&lt; "验证一维数组 定址公式" &lt;&lt; endl;cout &lt;&lt; "打印元素基址" &lt;&lt; a1 &lt;&lt; endl;cout &lt;&lt; "打印元素基址" &lt;&lt; a1+0 &lt;&lt; endl;//根据上面我们说的公式 假设 元素基址 = 0x7ffc39400340//那么 0x7ffc39400340 + 1 * 4 = 0x7ffc39400344;cout &lt;&lt; "打印第二个元素的地址" &lt;&lt; a1+1 &lt;&lt; endl;//验证二维数组 定址公式 = (b1+0) + (x * 2 + y) * sizeof(DataType)//注意公式里的 x y 和上面打印的不一样，上面的 x y 分别代表每个维度的长度，公式里面是每个维度的下标cout &lt;&lt; "验证二维数组 定址公式" &lt;&lt; endl;cout &lt;&lt; "打印元素基址" &lt;&lt; b1 &lt;&lt; endl;cout &lt;&lt; "打印元素基址" &lt;&lt; (b1 + 0 * y + 0) &lt;&lt; endl;//根据上面我们说的公式 假设 元素基址 = 0x7ffc39400340//那么 0x7ffc39400340 + (x * 2 + y) = 0x7ffc39400344;cout &lt;&lt; "打印第二个元素的地址" &lt;&lt; (b1 + 0 * y + 1) &lt;&lt; endl;//验证三维数组 定址公式 = (c1+0) + (h * 2 * 2 + w * 2 + d) * sizeof(DataType)//注意公式里的 h w y 和上面打印的不一样，上面的 h w y 分别代表每个维度的长度，公式里面是每个维度的下标cout &lt;&lt; "验证三维数组 定址公式" &lt;&lt; endl;cout &lt;&lt; "打印元素基址" &lt;&lt; c1 &lt;&lt; endl;cout &lt;&lt; "打印元素基址" &lt;&lt; c1+0 &lt;&lt; endl;//根据上面我们说的公式 假设 元素基址 = 0x7ffc39400340//那么 0x7ffc39400340 + 0 * 2 * 2 + 0 * 2 + 1 = 0x7ffc39400344;cout &lt;&lt; "打印第二个元素的地址" &lt;&lt; c1 + 0 * 2 * 2 + 0 * 2 + 1 &lt;&lt; endl; 总结数组就是数量固定且类型相同的元素集合。数组的的内存空间是连续的，有规律的，所以可以直接使用下表访问相应的元素。数组的查询是非常快的，因为它可以直接根据下标计算出内存地址，不用像 链表 一样，每次查询都需要遍历。数组的插入和删除是比较慢的，因为每次插入或删除一个元素的时候，都需要重新维护序号指针，除非操作的是最后一个元素。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
